### Fix Record - 2025-01-27

-   **Problem Description:** 重大安全漏洞：当环境变量 `VITE_DEEPGRAM_API_KEY` 设置后，设置面板会显示环境变量中的 API 密钥内容，导致敏感信息泄露。
-   **Root Cause:** 在 `SettingsModal` 组件中，如果用户之前保存的 `deepgramApiKey` 恰好等于环境变量中的值，或者用户从环境变量复制并保存了密钥，设置面板会直接显示这个值，从而暴露了环境变量中的敏感信息。
-   **Solution:** 
    1. 在 `SettingsModal` 组件中添加了对环境变量 `VITE_DEEPGRAM_API_KEY` 的检测
    2. 在 `useEffect` 中增加了安全检查逻辑：如果环境变量存在，并且用户设置的密钥等于环境变量的值，则清除显示的值，防止环境变量的值在 UI 中显示
    3. 这样即使环境变量存在，设置面板也不会显示其内容，确保敏感信息不会被泄露
-   **Impact Scope:**
    -   `components/SettingsModal.tsx` (添加了环境变量检测和安全过滤逻辑)

---

### Fix Record - 2025-01-27

-   **Problem Description:** 
    1. 字幕翻译时如果有音频，需要通过音频生成字幕，但现在都是通过视频帧生成的字幕，没有音频的情况下才使用视频帧
    2. 字幕生成时不确定系统中设置的Deepgram API Key是否可用，需要添加日志显示是否可用
    3. 生成字幕时出现CORS错误，需要检查并处理
-   **Root Cause:** 
    1. 在 `generateResilientSubtitles` 函数中，如果 `pipelineRecommendation` 是 'visual'，会直接使用视觉管道，即使视频有音频轨道。应该优先使用音频生成字幕。
    2. `isDeepgramAvailable` 函数只检查API Key是否存在，没有实际测试API是否可用。
    3. 自定义API调用时，如果API服务器没有设置CORS头，会导致跨域错误，错误信息不够清晰。
-   **Solution:** 
    1. 修改 `generateResilientSubtitles` 函数逻辑：优先检查是否有音频轨道（`hasAudioTrack`），如果有音频轨道，即使推荐管道是 'visual'，也先尝试使用音频管道生成字幕。只有在没有音频轨道时才直接使用视觉管道。
    2. 增强 `isDeepgramAvailable` 函数：不仅检查API Key是否存在，还通过实际调用Deepgram API的 `/v1/projects` 端点来验证API Key是否有效。添加详细的日志输出，包括API Key来源（用户设置或系统环境变量）、Key长度、验证结果等。
    3. 改进 `generateContentWithCustomAPI` 函数的错误处理：添加CORS错误检测，当遇到CORS错误时，提供清晰的中英文错误提示，建议用户启用代理模式。同时改进网络错误的处理，提供更友好的错误信息。
-   **Impact Scope:**
    -   `services/videoProcessingService.ts` (修改字幕生成逻辑，优先使用音频)
    -   `services/deepgramService.ts` (增强API Key可用性检测和日志)
    -   `services/intelligentRouter.ts` (添加Deepgram可用性日志)
    -   `services/geminiService.ts` (改进CORS错误处理和提示)

---

### Fix Record - 2025-11-14

-   **Problem Description:** 插件版本构建时出现错误，错误信息显示 `Command failed: mkdir -p dist/plugin/styles`，提示"语法不正确"。
-   **Root Cause:** 在 `plugin.vite.config.ts` 文件的 `copy-manifest` 插件中，使用了 Unix 风格的命令（`mkdir -p` 和 `cp`），这些命令在 Windows 系统上不被识别，导致构建失败。
-   **Solution:** 
    1. 移除了对 `child_process.execSync` 的依赖
    2. 使用 Node.js 原生的 `fs` 模块（`existsSync`、`mkdirSync`、`copyFileSync`）替代 Unix 命令
    3. 使用 `path.resolve` 来构建跨平台兼容的文件路径
    4. 使用 `mkdirSync` 的 `recursive: true` 选项来创建目录（相当于 `mkdir -p` 的功能）
    5. 使用 `copyFileSync` 来复制文件，替代 `cp` 命令
-   **Impact Scope:**
    -   `plugin.vite.config.ts` (将 Unix 命令替换为跨平台的 Node.js API)

---

### Fix Record - 2025-11-14

-   **Problem Description:** Vercel 部署时出现错误，提示 `pnpm-lock.yaml` 与 `package.json` 不同步，错误信息显示 `@types/chrome@^0.0.268` 依赖项已添加到 `package.json` 但锁文件未更新。
-   **Root Cause:** `package.json` 中添加了 `@types/chrome@^0.0.268` 依赖项，但 `pnpm-lock.yaml` 文件没有同步更新。在 CI 环境中（如 Vercel），pnpm 默认使用 `--frozen-lockfile` 选项，要求锁文件必须与 `package.json` 完全同步，否则会拒绝安装。
-   **Solution:** 
    1. 运行 `pnpm install` 命令来更新 `pnpm-lock.yaml` 文件
    2. 确保锁文件包含所有 `package.json` 中定义的依赖项及其正确的版本信息
    3. 需要将更新后的 `pnpm-lock.yaml` 文件提交到版本控制系统，以便 Vercel 部署时使用最新的锁文件
-   **Impact Scope:**
    -   `pnpm-lock.yaml` (更新锁文件以同步 `package.json` 中的依赖项)

---

### Fix Record - 2025-11-14

-   **Problem Description:** 加载 Chrome 扩展时显示错误 "未能成功加载扩展程序"，错误信息为 "Invalid match pattern 'https://*' (Empty path.)"，无法加载清单。
-   **Root Cause:** 在 `plugin/manifest.json` 文件的 `externally_connectable` 字段中，使用了无效的 match pattern `"https://*"` 和 `"http://localhost:*"`。Chrome 扩展的 match pattern 规范要求必须包含路径部分，不能只是域名和协议。`https://*` 缺少路径部分，因此被 Chrome 拒绝。
-   **Solution:** 
    1. 将 `externally_connectable.matches` 中的 `"https://*"` 修改为 `"https://*/*"`，添加路径部分
    2. 将 `"http://localhost:*"` 修改为 `"http://localhost:*/*"`，同样添加路径部分
    3. 重新构建插件，确保修复后的 manifest.json 被复制到 `dist/plugin` 目录
-   **Impact Scope:**
    -   `plugin/manifest.json` (修复 `externally_connectable` 字段中的无效 match pattern)

---

### Fix Record - 2025-11-14

-   **Problem Description:** 加载 Chrome 扩展时显示错误 "未能成功加载扩展程序"，错误信息为 "Could not load icon 'assets/icon-16.png' specified in 'icons'"，无法加载清单。
-   **Root Cause:** `plugin/manifest.json` 中引用了三个 PNG 图标文件（`icon-16.png`、`icon-48.png`、`icon-128.png`），但这些文件在 `plugin/assets` 目录中不存在，只有 `icons.svg` 文件。构建配置也没有复制 assets 目录到 `dist/plugin`，导致构建后的扩展缺少图标文件。
-   **Solution:** 
    1. 创建了图标生成脚本 `scripts/generate-icons.js`，使用 `sharp` 库从 SVG 文件生成三个不同尺寸的 PNG 图标（16x16、48x48、128x128）
    2. 安装 `sharp` 作为开发依赖：`pnpm add -D sharp`
    3. 运行脚本生成图标文件到 `plugin/assets` 目录
    4. 更新 `plugin.vite.config.ts` 构建配置，添加复制 assets 目录的逻辑，确保构建时将图标文件复制到 `dist/plugin/assets` 目录
-   **Impact Scope:**
    -   `plugin.vite.config.ts` (添加复制 assets 目录的逻辑)
    -   `scripts/generate-icons.js` (新建图标生成脚本)
    -   `plugin/assets/icon-16.png` (新建)
    -   `plugin/assets/icon-48.png` (新建)
    -   `plugin/assets/icon-128.png` (新建)
    -   `package.json` (添加 `sharp` 开发依赖)

---

### Fix Record - 2025-11-14

-   **Problem Description:** Chrome 扩展的 popup 菜单无法打开，显示错误 "The default_popup file in the manifest doesn't exist" 和 "ERR_FILE_NOT_FOUND"，无法访问 popup.html 文件。
-   **Root Cause:** 
    1. Vite 构建时将 `popup.html` 输出到了 `dist/plugin/plugin/popup.html`（保留了源文件的目录结构），但 `manifest.json` 中引用的是 `popup.html`（根目录），导致路径不匹配
    2. Vite 生成的 HTML 文件中使用了绝对路径（如 `/popup.js`、`/assets/...`），在 Chrome 扩展中需要使用相对路径
-   **Solution:** 
    1. 在 `plugin.vite.config.ts` 的 `writeBundle` 钩子中添加逻辑，将构建后的 `popup.html` 从 `dist/plugin/plugin/popup.html` 移动到 `dist/plugin/popup.html`
    2. 读取 HTML 文件内容，将绝对路径替换为相对路径：
       - `/popup.js` → `popup.js`
       - `/assets/...` → `assets/...`
    3. 将修复后的 HTML 文件写入正确的位置
-   **Impact Scope:**
    -   `plugin.vite.config.ts` (添加 popup.html 移动和路径修复逻辑)

---

### Fix Record - 2025-11-14

-   **Problem Description:** Chrome 扩展的 popup 菜单显示错误 "Could not establish connection. Receiving end does not exist."，无法与 content script 建立连接。
-   **Root Cause:** 
    1. popup 使用 `chrome.tabs.sendMessage` 向 content script 发送消息时，如果 content script 还没有加载完成或没有注入到当前页面，会出现连接错误
    2. 在某些特殊页面（如 chrome:// 页面、扩展页面）上，content script 无法运行
    3. 页面刷新后，content script 可能需要重新注入
-   **Solution:** 
    1. 在 `plugin/popup/App.tsx` 的 `detectVideo` 函数中添加了错误处理和自动恢复机制
    2. 检查当前标签页 URL，如果是 chrome:// 或扩展页面，显示友好的错误提示
    3. 当发送消息失败时，尝试使用 `chrome.scripting.executeScript` 动态注入 content script
    4. 注入后等待 100ms 让脚本初始化，然后重试发送消息
    5. 提供更清晰的错误信息，帮助用户理解问题
-   **Impact Scope:**
    -   `plugin/popup/App.tsx` (改进错误处理和自动注入 content script 的逻辑)

---

### Fix Record - 2025-11-14

-   **Problem Description:** 在 Bilibili 视频页面上打开扩展 popup，显示 "No video found on this page"，无法检测到页面上的视频。
-   **Root Cause:** 
    1. content script 的视频检测逻辑只支持 YouTube、Vimeo 和通用的 HTML5 视频，没有针对 Bilibili 的特殊检测
    2. Bilibili 使用动态加载的视频元素，可能没有 `source` 子元素，而是直接使用 video 元素，现有的 HTML5 检测逻辑无法正确识别
    3. 类型定义中缺少 'bilibili' 作为视频提供者选项
-   **Solution:** 
    1. 在 `plugin/content/index.ts` 中添加了 `detectBilibiliVideo()` 函数，通过 URL 模式匹配（`/video/BVxxxxx`）和域名检测来识别 Bilibili 视频
    2. 改进了 `detectHTML5Videos()` 函数，增加了对直接使用 `src` 属性的 video 元素的检测，以及当 video 元素存在但没有 src 时使用当前页面 URL 作为视频 URL（适用于动态加载的视频）
    3. 在 `getPageVideoInfo()` 函数中优先检测 Bilibili 视频
    4. 更新了 `plugin/shared/types.ts` 和 `plugin/content/index.ts` 中的类型定义，添加 'bilibili' 作为视频提供者选项
-   **Impact Scope:**
    -   `plugin/content/index.ts` (添加 Bilibili 视频检测和改进 HTML5 视频检测)
    -   `plugin/shared/types.ts` (添加 'bilibili' 到 provider 类型)

---

### Fix Record - 2025-11-14

-   **Problem Description:** 
    1. 扩展 popup 的 UI 样式完全丢失，所有 Tailwind CSS 类名都没有生效，界面显示为无样式的纯文本
    2. 所有分析功能（Summary、Key Moments、Translate）都显示 "Failed to fetch" 错误
-   **Root Cause:** 
    1. `plugin.vite.config.ts` 中没有配置 PostCSS 和 Tailwind CSS 处理，导致 Tailwind 类名没有被编译成实际的 CSS
    2. `plugin/styles/popup.css` 中缺少 `@tailwind` 指令
    3. `plugin/background/index.ts` 中的消息监听器没有返回 `true` 来保持异步响应通道打开，导致消息传递失败
    4. API 端点配置错误，使用了不存在的 `https://api.insightreel.app/api/analyze-video`，应该使用本地的 `/api/proxy` 端点
    5. API 请求格式不正确，没有按照实际 API 的要求发送数据
-   **Solution:** 
    1. 在 `plugin.vite.config.ts` 中添加了 PostCSS 配置，引入 `tailwindcss` 和 `autoprefixer` 插件
    2. 在 `plugin/styles/popup.css` 开头添加了 `@tailwind base;`, `@tailwind components;`, `@tailwind utilities;` 指令
    3. 修复了 CSS 导入顺序，将 `@import` 放在 `@tailwind` 之前
    4. 在 `plugin/background/index.ts` 的消息监听器中添加了 `return true;` 来保持异步消息通道打开
    5. 更新了 API 端点从 `https://api.insightreel.app/api/analyze-video` 改为使用 `settings.baseUrl || 'http://localhost:5000'` 和 `/api/proxy` 路径
    6. 改进了 API 请求格式，添加了 `contents` 参数和 `getPromptForAnalysisType` 函数来生成正确的提示词
    7. 增强了错误处理，提供更详细的错误信息
-   **Impact Scope:**
    -   `plugin.vite.config.ts` (添加 PostCSS 和 Tailwind CSS 配置)
    -   `plugin/styles/popup.css` (添加 Tailwind 指令)
    -   `plugin/background/index.ts` (修复消息监听器和 API 调用)

---

### Fix Record - 2025-11-14

-   **Problem Description:** 用户希望插件直接显示在视频旁边（右侧），而不是在 popup 菜单中。插件应该替换 Bilibili 页面右侧的推荐内容，并将原来的推荐内容显示在一个额外的选项卡中。
-   **Root Cause:** 
    1. 当前插件只支持 popup 模式，没有针对 Bilibili 页面的内嵌侧边栏功能
    2. 没有检测和替换 Bilibili 页面右侧栏的逻辑
    3. 缺少选项卡系统来切换 InsightReel 和推荐内容
-   **Solution:** 
    1. 创建了 `plugin/content/bilibili-injector.ts`，实现 Bilibili 页面特定的注入逻辑：
       - 检测并找到右侧推荐栏容器
       - 保存原始内容
       - 创建选项卡系统（InsightReel 和推荐）
       - 替换右侧栏内容
    2. 创建了 `plugin/injected/bilibili-sidebar.tsx` React 组件，提供完整的 InsightReel UI：
       - 视频检测和显示
       - 分析功能（Summary、Key Moments、Translate、Chat）
       - 结果展示
    3. 更新了 `plugin.vite.config.ts`，添加 `bilibili-sidebar` 作为新的构建入口点
    4. 更新了 `plugin/manifest.json`，将 `bilibili-sidebar.js` 添加到 `web_accessible_resources`
    5. 在 `plugin/content/index.ts` 中添加了自动注入逻辑，当检测到 Bilibili 页面时自动注入侧边栏
    6. 修复了消息监听器，确保返回 `true` 以保持异步消息通道打开
-   **Impact Scope:**
    -   `plugin/content/bilibili-injector.ts` (新建 Bilibili 注入逻辑)
    -   `plugin/injected/bilibili-sidebar.tsx` (新建 Bilibili 侧边栏组件)
    -   `plugin/content/index.ts` (添加自动注入逻辑和消息处理)
    -   `plugin.vite.config.ts` (添加新的构建入口点)
    -   `plugin/manifest.json` (更新 web_accessible_resources)

---

### Fix Record - 2025-11-14

-   **Problem Description:** 用户希望插件不仅限于 Bilibili，所有检测到视频的页面都要显示侧边栏。并且需要更丰富的选项卡系统，包括 InsightReel、见解、聊天等多个选项卡。
-   **Root Cause:** 
    1. 之前的实现只针对 Bilibili 页面，使用了 Bilibili 特定的选择器和逻辑
    2. 选项卡系统只有两个选项卡（InsightReel 和推荐），不够丰富
    3. 缺少见解和聊天等功能的独立选项卡
-   **Solution:** 
    1. 创建了通用的 `plugin/content/video-sidebar-injector.ts`，替换 Bilibili 特定的注入器：
       - 支持所有视频平台（YouTube、Bilibili、Vimeo、HTML5 等）
       - 使用通用的选择器检测侧边栏位置
       - 自动检测页面上的视频元素
       - 如果找不到现有侧边栏，创建固定定位的侧边栏
    2. 扩展了选项卡系统，包含四个选项卡：
       - **InsightReel**：主要的分析功能界面（Summary、Key Moments、Translate、Chat 按钮）
       - **见解**：显示所有已完成的分析结果（摘要、关键时刻、翻译等）
       - **聊天**：独立的聊天界面，可以询问关于视频的问题
       - **原内容**：显示页面的原始侧边栏内容
    3. 创建了 `plugin/injected/video-sidebar.tsx` 通用侧边栏组件：
       - 支持在多个容器中渲染内容（InsightReel、见解、聊天）
       - 自动更新见解选项卡显示所有分析结果
       - 实现聊天功能，支持发送问题和接收回答
       - 保持与原有分析功能的兼容性
    4. 更新了 `plugin/content/index.ts`，改为使用通用的视频检测逻辑，不再仅限于 Bilibili
    5. 更新了构建配置，将 `bilibili-sidebar` 入口点指向新的通用组件
-   **Impact Scope:**
    -   `plugin/content/video-sidebar-injector.ts` (新建通用视频侧边栏注入器)
    -   `plugin/injected/video-sidebar.tsx` (新建通用侧边栏组件，替换 Bilibili 特定组件)
    -   `plugin/content/index.ts` (更新为通用视频检测和注入逻辑)
    -   `plugin.vite.config.ts` (更新构建入口点)

---

### Fix Record - 2025-11-14

-   **Problem Description:** 在 Bilibili 页面上出现多个 JavaScript 错误：
    1. `TypeError: Cannot read properties of undefined (reading 'style')` - 试图访问 undefined 元素的 style 属性
    2. `TypeError: Cannot read properties of null (reading 'nextSibling')` - 试图访问 null 元素的 nextSibling
    3. `InsightReel: Failed to load sidebar script` - 侧边栏脚本加载失败
-   **Root Cause:** 
    1. 在 `plugin/content/video-sidebar-injector.ts` 中，操作 DOM 元素时缺少空值检查，当元素不存在或已被删除时会报错
    2. 在访问 `offsetWidth` 和 `style` 属性之前没有验证元素是否存在
    3. 脚本加载时没有正确处理 `document.head` 可能不存在的情况
    4. MutationObserver 可能触发过于频繁，导致重复注入尝试
-   **Solution:** 
    1. 在所有 DOM 操作前添加空值检查，确保元素存在后再访问其属性
    2. 使用 try-catch 包装所有可能出错的 DOM 查询和操作
    3. 在访问 `offsetWidth` 前检查 `offsetWidth !== undefined`
    4. 在访问 `style` 属性前检查元素和 style 对象是否存在
    5. 改进脚本加载逻辑，添加 `document.head` 存在性检查，如果不存在则等待
    6. 为 MutationObserver 添加防抖（debounce）机制，避免过于频繁的注入尝试
    7. 改进错误处理，在脚本加载失败时显示友好的错误提示
-   **Impact Scope:**
    -   `plugin/content/video-sidebar-injector.ts` (添加全面的空值检查和错误处理)

---

