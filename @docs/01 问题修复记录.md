### Fix Record - 2025-01-27

-   **Problem Description:** 重大安全漏洞：当环境变量 `VITE_DEEPGRAM_API_KEY` 设置后，设置面板会显示环境变量中的 API 密钥内容，导致敏感信息泄露。
-   **Root Cause:** 在 `SettingsModal` 组件中，如果用户之前保存的 `deepgramApiKey` 恰好等于环境变量中的值，或者用户从环境变量复制并保存了密钥，设置面板会直接显示这个值，从而暴露了环境变量中的敏感信息。
-   **Solution:** 
    1. 在 `SettingsModal` 组件中添加了对环境变量 `VITE_DEEPGRAM_API_KEY` 的检测
    2. 在 `useEffect` 中增加了安全检查逻辑：如果环境变量存在，并且用户设置的密钥等于环境变量的值，则清除显示的值，防止环境变量的值在 UI 中显示
    3. 这样即使环境变量存在，设置面板也不会显示其内容，确保敏感信息不会被泄露
-   **Impact Scope:**
    -   `components/SettingsModal.tsx` (添加了环境变量检测和安全过滤逻辑)

---

### Fix Record - 2025-01-27

-   **Problem Description:** 
    1. 字幕翻译时如果有音频，需要通过音频生成字幕，但现在都是通过视频帧生成的字幕，没有音频的情况下才使用视频帧
    2. 字幕生成时不确定系统中设置的Deepgram API Key是否可用，需要添加日志显示是否可用
    3. 生成字幕时出现CORS错误，需要检查并处理
-   **Root Cause:** 
    1. 在 `generateResilientSubtitles` 函数中，如果 `pipelineRecommendation` 是 'visual'，会直接使用视觉管道，即使视频有音频轨道。应该优先使用音频生成字幕。
    2. `isDeepgramAvailable` 函数只检查API Key是否存在，没有实际测试API是否可用。
    3. 自定义API调用时，如果API服务器没有设置CORS头，会导致跨域错误，错误信息不够清晰。
-   **Solution:** 
    1. 修改 `generateResilientSubtitles` 函数逻辑：优先检查是否有音频轨道（`hasAudioTrack`），如果有音频轨道，即使推荐管道是 'visual'，也先尝试使用音频管道生成字幕。只有在没有音频轨道时才直接使用视觉管道。
    2. 增强 `isDeepgramAvailable` 函数：不仅检查API Key是否存在，还通过实际调用Deepgram API的 `/v1/projects` 端点来验证API Key是否有效。添加详细的日志输出，包括API Key来源（用户设置或系统环境变量）、Key长度、验证结果等。
    3. 改进 `generateContentWithCustomAPI` 函数的错误处理：添加CORS错误检测，当遇到CORS错误时，提供清晰的中英文错误提示，建议用户启用代理模式。同时改进网络错误的处理，提供更友好的错误信息。
-   **Impact Scope:**
    -   `services/videoProcessingService.ts` (修改字幕生成逻辑，优先使用音频)
    -   `services/deepgramService.ts` (增强API Key可用性检测和日志)
    -   `services/intelligentRouter.ts` (添加Deepgram可用性日志)
    -   `services/geminiService.ts` (改进CORS错误处理和提示)

---

### Fix Record - 2025-11-14

-   **Problem Description:** 插件版本构建时出现错误，错误信息显示 `Command failed: mkdir -p dist/plugin/styles`，提示"语法不正确"。
-   **Root Cause:** 在 `plugin.vite.config.ts` 文件的 `copy-manifest` 插件中，使用了 Unix 风格的命令（`mkdir -p` 和 `cp`），这些命令在 Windows 系统上不被识别，导致构建失败。
-   **Solution:** 
    1. 移除了对 `child_process.execSync` 的依赖
    2. 使用 Node.js 原生的 `fs` 模块（`existsSync`、`mkdirSync`、`copyFileSync`）替代 Unix 命令
    3. 使用 `path.resolve` 来构建跨平台兼容的文件路径
    4. 使用 `mkdirSync` 的 `recursive: true` 选项来创建目录（相当于 `mkdir -p` 的功能）
    5. 使用 `copyFileSync` 来复制文件，替代 `cp` 命令
-   **Impact Scope:**
    -   `plugin.vite.config.ts` (将 Unix 命令替换为跨平台的 Node.js API)

---

### Fix Record - 2025-11-14

-   **Problem Description:** Vercel 部署时出现错误，提示 `pnpm-lock.yaml` 与 `package.json` 不同步，错误信息显示 `@types/chrome@^0.0.268` 依赖项已添加到 `package.json` 但锁文件未更新。
-   **Root Cause:** `package.json` 中添加了 `@types/chrome@^0.0.268` 依赖项，但 `pnpm-lock.yaml` 文件没有同步更新。在 CI 环境中（如 Vercel），pnpm 默认使用 `--frozen-lockfile` 选项，要求锁文件必须与 `package.json` 完全同步，否则会拒绝安装。
-   **Solution:** 
    1. 运行 `pnpm install` 命令来更新 `pnpm-lock.yaml` 文件
    2. 确保锁文件包含所有 `package.json` 中定义的依赖项及其正确的版本信息
    3. 需要将更新后的 `pnpm-lock.yaml` 文件提交到版本控制系统，以便 Vercel 部署时使用最新的锁文件
-   **Impact Scope:**
    -   `pnpm-lock.yaml` (更新锁文件以同步 `package.json` 中的依赖项)

---

### Fix Record - 2025-11-14

-   **Problem Description:** 加载 Chrome 扩展时显示错误 "未能成功加载扩展程序"，错误信息为 "Invalid match pattern 'https://*' (Empty path.)"，无法加载清单。
-   **Root Cause:** 在 `plugin/manifest.json` 文件的 `externally_connectable` 字段中，使用了无效的 match pattern `"https://*"` 和 `"http://localhost:*"`。Chrome 扩展的 match pattern 规范要求必须包含路径部分，不能只是域名和协议。`https://*` 缺少路径部分，因此被 Chrome 拒绝。
-   **Solution:** 
    1. 将 `externally_connectable.matches` 中的 `"https://*"` 修改为 `"https://*/*"`，添加路径部分
    2. 将 `"http://localhost:*"` 修改为 `"http://localhost:*/*"`，同样添加路径部分
    3. 重新构建插件，确保修复后的 manifest.json 被复制到 `dist/plugin` 目录
-   **Impact Scope:**
    -   `plugin/manifest.json` (修复 `externally_connectable` 字段中的无效 match pattern)

---

### Fix Record - 2025-11-14

-   **Problem Description:** 加载 Chrome 扩展时显示错误 "未能成功加载扩展程序"，错误信息为 "Could not load icon 'assets/icon-16.png' specified in 'icons'"，无法加载清单。
-   **Root Cause:** `plugin/manifest.json` 中引用了三个 PNG 图标文件（`icon-16.png`、`icon-48.png`、`icon-128.png`），但这些文件在 `plugin/assets` 目录中不存在，只有 `icons.svg` 文件。构建配置也没有复制 assets 目录到 `dist/plugin`，导致构建后的扩展缺少图标文件。
-   **Solution:** 
    1. 创建了图标生成脚本 `scripts/generate-icons.js`，使用 `sharp` 库从 SVG 文件生成三个不同尺寸的 PNG 图标（16x16、48x48、128x128）
    2. 安装 `sharp` 作为开发依赖：`pnpm add -D sharp`
    3. 运行脚本生成图标文件到 `plugin/assets` 目录
    4. 更新 `plugin.vite.config.ts` 构建配置，添加复制 assets 目录的逻辑，确保构建时将图标文件复制到 `dist/plugin/assets` 目录
-   **Impact Scope:**
    -   `plugin.vite.config.ts` (添加复制 assets 目录的逻辑)
    -   `scripts/generate-icons.js` (新建图标生成脚本)
    -   `plugin/assets/icon-16.png` (新建)
    -   `plugin/assets/icon-48.png` (新建)
    -   `plugin/assets/icon-128.png` (新建)
    -   `package.json` (添加 `sharp` 开发依赖)

---

### Fix Record - 2025-11-14

-   **Problem Description:** Chrome 扩展的 popup 菜单无法打开，显示错误 "The default_popup file in the manifest doesn't exist" 和 "ERR_FILE_NOT_FOUND"，无法访问 popup.html 文件。
-   **Root Cause:** 
    1. Vite 构建时将 `popup.html` 输出到了 `dist/plugin/plugin/popup.html`（保留了源文件的目录结构），但 `manifest.json` 中引用的是 `popup.html`（根目录），导致路径不匹配
    2. Vite 生成的 HTML 文件中使用了绝对路径（如 `/popup.js`、`/assets/...`），在 Chrome 扩展中需要使用相对路径
-   **Solution:** 
    1. 在 `plugin.vite.config.ts` 的 `writeBundle` 钩子中添加逻辑，将构建后的 `popup.html` 从 `dist/plugin/plugin/popup.html` 移动到 `dist/plugin/popup.html`
    2. 读取 HTML 文件内容，将绝对路径替换为相对路径：
       - `/popup.js` → `popup.js`
       - `/assets/...` → `assets/...`
    3. 将修复后的 HTML 文件写入正确的位置
-   **Impact Scope:**
    -   `plugin.vite.config.ts` (添加 popup.html 移动和路径修复逻辑)

---

### Fix Record - 2025-11-14

-   **Problem Description:** Chrome 扩展的 popup 菜单显示错误 "Could not establish connection. Receiving end does not exist."，无法与 content script 建立连接。
-   **Root Cause:** 
    1. popup 使用 `chrome.tabs.sendMessage` 向 content script 发送消息时，如果 content script 还没有加载完成或没有注入到当前页面，会出现连接错误
    2. 在某些特殊页面（如 chrome:// 页面、扩展页面）上，content script 无法运行
    3. 页面刷新后，content script 可能需要重新注入
-   **Solution:** 
    1. 在 `plugin/popup/App.tsx` 的 `detectVideo` 函数中添加了错误处理和自动恢复机制
    2. 检查当前标签页 URL，如果是 chrome:// 或扩展页面，显示友好的错误提示
    3. 当发送消息失败时，尝试使用 `chrome.scripting.executeScript` 动态注入 content script
    4. 注入后等待 100ms 让脚本初始化，然后重试发送消息
    5. 提供更清晰的错误信息，帮助用户理解问题
-   **Impact Scope:**
    -   `plugin/popup/App.tsx` (改进错误处理和自动注入 content script 的逻辑)

---

### Fix Record - 2025-11-14

-   **Problem Description:** 在 Bilibili 视频页面上打开扩展 popup，显示 "No video found on this page"，无法检测到页面上的视频。
-   **Root Cause:** 
    1. content script 的视频检测逻辑只支持 YouTube、Vimeo 和通用的 HTML5 视频，没有针对 Bilibili 的特殊检测
    2. Bilibili 使用动态加载的视频元素，可能没有 `source` 子元素，而是直接使用 video 元素，现有的 HTML5 检测逻辑无法正确识别
    3. 类型定义中缺少 'bilibili' 作为视频提供者选项
-   **Solution:** 
    1. 在 `plugin/content/index.ts` 中添加了 `detectBilibiliVideo()` 函数，通过 URL 模式匹配（`/video/BVxxxxx`）和域名检测来识别 Bilibili 视频
    2. 改进了 `detectHTML5Videos()` 函数，增加了对直接使用 `src` 属性的 video 元素的检测，以及当 video 元素存在但没有 src 时使用当前页面 URL 作为视频 URL（适用于动态加载的视频）
    3. 在 `getPageVideoInfo()` 函数中优先检测 Bilibili 视频
    4. 更新了 `plugin/shared/types.ts` 和 `plugin/content/index.ts` 中的类型定义，添加 'bilibili' 作为视频提供者选项
-   **Impact Scope:**
    -   `plugin/content/index.ts` (添加 Bilibili 视频检测和改进 HTML5 视频检测)
    -   `plugin/shared/types.ts` (添加 'bilibili' 到 provider 类型)

---

### Fix Record - 2025-11-14

-   **Problem Description:** 
    1. 扩展 popup 的 UI 样式完全丢失，所有 Tailwind CSS 类名都没有生效，界面显示为无样式的纯文本
    2. 所有分析功能（Summary、Key Moments、Translate）都显示 "Failed to fetch" 错误
-   **Root Cause:** 
    1. `plugin.vite.config.ts` 中没有配置 PostCSS 和 Tailwind CSS 处理，导致 Tailwind 类名没有被编译成实际的 CSS
    2. `plugin/styles/popup.css` 中缺少 `@tailwind` 指令
    3. `plugin/background/index.ts` 中的消息监听器没有返回 `true` 来保持异步响应通道打开，导致消息传递失败
    4. API 端点配置错误，使用了不存在的 `https://api.insightreel.app/api/analyze-video`，应该使用本地的 `/api/proxy` 端点
    5. API 请求格式不正确，没有按照实际 API 的要求发送数据
-   **Solution:** 
    1. 在 `plugin.vite.config.ts` 中添加了 PostCSS 配置，引入 `tailwindcss` 和 `autoprefixer` 插件
    2. 在 `plugin/styles/popup.css` 开头添加了 `@tailwind base;`, `@tailwind components;`, `@tailwind utilities;` 指令
    3. 修复了 CSS 导入顺序，将 `@import` 放在 `@tailwind` 之前
    4. 在 `plugin/background/index.ts` 的消息监听器中添加了 `return true;` 来保持异步消息通道打开
    5. 更新了 API 端点从 `https://api.insightreel.app/api/analyze-video` 改为使用 `settings.baseUrl || 'http://localhost:5000'` 和 `/api/proxy` 路径
    6. 改进了 API 请求格式，添加了 `contents` 参数和 `getPromptForAnalysisType` 函数来生成正确的提示词
    7. 增强了错误处理，提供更详细的错误信息
-   **Impact Scope:**
    -   `plugin.vite.config.ts` (添加 PostCSS 和 Tailwind CSS 配置)
    -   `plugin/styles/popup.css` (添加 Tailwind 指令)
    -   `plugin/background/index.ts` (修复消息监听器和 API 调用)

---

### Fix Record - 2025-11-14

-   **Problem Description:** 用户希望插件直接显示在视频旁边（右侧），而不是在 popup 菜单中。插件应该替换 Bilibili 页面右侧的推荐内容，并将原来的推荐内容显示在一个额外的选项卡中。
-   **Root Cause:** 
    1. 当前插件只支持 popup 模式，没有针对 Bilibili 页面的内嵌侧边栏功能
    2. 没有检测和替换 Bilibili 页面右侧栏的逻辑
    3. 缺少选项卡系统来切换 InsightReel 和推荐内容
-   **Solution:** 
    1. 创建了 `plugin/content/bilibili-injector.ts`，实现 Bilibili 页面特定的注入逻辑：
       - 检测并找到右侧推荐栏容器
       - 保存原始内容
       - 创建选项卡系统（InsightReel 和推荐）
       - 替换右侧栏内容
    2. 创建了 `plugin/injected/bilibili-sidebar.tsx` React 组件，提供完整的 InsightReel UI：
       - 视频检测和显示
       - 分析功能（Summary、Key Moments、Translate、Chat）
       - 结果展示
    3. 更新了 `plugin.vite.config.ts`，添加 `bilibili-sidebar` 作为新的构建入口点
    4. 更新了 `plugin/manifest.json`，将 `bilibili-sidebar.js` 添加到 `web_accessible_resources`
    5. 在 `plugin/content/index.ts` 中添加了自动注入逻辑，当检测到 Bilibili 页面时自动注入侧边栏
    6. 修复了消息监听器，确保返回 `true` 以保持异步消息通道打开
-   **Impact Scope:**
    -   `plugin/content/bilibili-injector.ts` (新建 Bilibili 注入逻辑)
    -   `plugin/injected/bilibili-sidebar.tsx` (新建 Bilibili 侧边栏组件)
    -   `plugin/content/index.ts` (添加自动注入逻辑和消息处理)
    -   `plugin.vite.config.ts` (添加新的构建入口点)
    -   `plugin/manifest.json` (更新 web_accessible_resources)

---

### Fix Record - 2025-11-14

-   **Problem Description:** 用户希望插件不仅限于 Bilibili，所有检测到视频的页面都要显示侧边栏。并且需要更丰富的选项卡系统，包括 InsightReel、见解、聊天等多个选项卡。
-   **Root Cause:** 
    1. 之前的实现只针对 Bilibili 页面，使用了 Bilibili 特定的选择器和逻辑
    2. 选项卡系统只有两个选项卡（InsightReel 和推荐），不够丰富
    3. 缺少见解和聊天等功能的独立选项卡
-   **Solution:** 
    1. 创建了通用的 `plugin/content/video-sidebar-injector.ts`，替换 Bilibili 特定的注入器：
       - 支持所有视频平台（YouTube、Bilibili、Vimeo、HTML5 等）
       - 使用通用的选择器检测侧边栏位置
       - 自动检测页面上的视频元素
       - 如果找不到现有侧边栏，创建固定定位的侧边栏
    2. 扩展了选项卡系统，包含四个选项卡：
       - **InsightReel**：主要的分析功能界面（Summary、Key Moments、Translate、Chat 按钮）
       - **见解**：显示所有已完成的分析结果（摘要、关键时刻、翻译等）
       - **聊天**：独立的聊天界面，可以询问关于视频的问题
       - **原内容**：显示页面的原始侧边栏内容
    3. 创建了 `plugin/injected/video-sidebar.tsx` 通用侧边栏组件：
       - 支持在多个容器中渲染内容（InsightReel、见解、聊天）
       - 自动更新见解选项卡显示所有分析结果
       - 实现聊天功能，支持发送问题和接收回答
       - 保持与原有分析功能的兼容性
    4. 更新了 `plugin/content/index.ts`，改为使用通用的视频检测逻辑，不再仅限于 Bilibili
    5. 更新了构建配置，将 `bilibili-sidebar` 入口点指向新的通用组件
-   **Impact Scope:**
    -   `plugin/content/video-sidebar-injector.ts` (新建通用视频侧边栏注入器)
    -   `plugin/injected/video-sidebar.tsx` (新建通用侧边栏组件，替换 Bilibili 特定组件)
    -   `plugin/content/index.ts` (更新为通用视频检测和注入逻辑)
    -   `plugin.vite.config.ts` (更新构建入口点)

---

### Fix Record - 2025-11-14

-   **Problem Description:** 在 Bilibili 页面上出现多个 JavaScript 错误：
    1. `TypeError: Cannot read properties of undefined (reading 'style')` - 试图访问 undefined 元素的 style 属性
    2. `TypeError: Cannot read properties of null (reading 'nextSibling')` - 试图访问 null 元素的 nextSibling
    3. `InsightReel: Failed to load sidebar script` - 侧边栏脚本加载失败
-   **Root Cause:** 
    1. 在 `plugin/content/video-sidebar-injector.ts` 中，操作 DOM 元素时缺少空值检查，当元素不存在或已被删除时会报错
    2. 在访问 `offsetWidth` 和 `style` 属性之前没有验证元素是否存在
    3. 脚本加载时没有正确处理 `document.head` 可能不存在的情况
    4. MutationObserver 可能触发过于频繁，导致重复注入尝试
-   **Solution:** 
    1. 在所有 DOM 操作前添加空值检查，确保元素存在后再访问其属性
    2. 使用 try-catch 包装所有可能出错的 DOM 查询和操作
    3. 在访问 `offsetWidth` 前检查 `offsetWidth !== undefined`
    4. 在访问 `style` 属性前检查元素和 style 对象是否存在
    5. 改进脚本加载逻辑，添加 `document.head` 存在性检查，如果不存在则等待
    6. 为 MutationObserver 添加防抖（debounce）机制，避免过于频繁的注入尝试
    7. 改进错误处理，在脚本加载失败时显示友好的错误提示
-   **Impact Scope:**
    -   `plugin/content/video-sidebar-injector.ts` (添加全面的空值检查和错误处理)

---

### Fix Record - 2025-01-27

-   **Problem Description:** 设置面板和登录面板的视觉风格与之前优化的 VideoDetail 页面风格不一致，存在信息结构正确但视觉风格不统一的问题。具体表现为：文字说明过重、边线过多、视觉密度高、缺乏留白，与 Notion 简约柔和的风格有明显差异。
-   **Root Cause:** 
    1. SettingsModal 和 AuthModal 使用了不同的 modal 外壳样式（`rounded-2xl + border + 渐变背景 + 较硬的阴影`），与 VideoDetail 的 `rounded-3xl + 白底 + 柔和阴影` 风格不一致
    2. SettingsModal 内容区域是长列表形式，每一块都有 label + 说明 + 边框，阅读成本高，缺乏分组
    3. 输入控件使用了"毛玻璃 + 边框"样式，与整体风格不统一
    4. AccountPanel 使用了多层边框和较重的视觉元素，看起来像后台配置页而非个人中心
-   **Solution:** 
    1. **统一所有弹窗的"外壳"**：将所有 modal 统一为 `rounded-[32px] + 白底 + 强阴影` 风格，关闭按钮使用更柔和的样式
    2. **SettingsModal 重构**：
       - 按功能将内容分为三个区块：General（语言、Provider、Proxy）、Model & API（model、baseUrl、apiKey）、Speech-to-Text（Deepgram、OpenAI + 智能路由说明）
       - 每个区块使用 section 标签，添加小标题（`text-xs font-semibold uppercase tracking-[0.14em]`）
       - 输入控件统一为 `rounded-2xl bg-slate-50` 样式，去掉毛玻璃效果
       - 说明文字精简，字号统一为 `text-xs`
       - 底部工具条改为更扁平的 Footer，按钮使用 `rounded-full` 样式
    3. **AuthModal 重构**：
       - 复用统一的 modal 外壳
       - 表单字段 label 使用 `text-xs font-medium text-slate-600`
       - 输入框使用统一的 `rounded-2xl bg-slate-50` 样式
       - 主按钮全宽、`rounded-full bg-slate-900 h-10`
       - 社交登录按钮改为 outline pill 样式
    4. **AccountPanel 重构**：
       - 外层卡片改为 `rounded-[32px] bg-white/95 shadow-[0_18px_80px_rgba(15,23,42,0.18)]`，去掉边框
       - 头部去掉 `border-b`，靠空间分区
       - 各功能区改为"信息卡片"样式，使用 `rounded-2xl bg-slate-50`，减少边框
       - 状态提示条统一为 `rounded-2xl` 并添加柔和阴影
       - 所有按钮统一为 `rounded-full` 样式
-   **Impact Scope:**
    -   `components/SettingsModal.tsx` (重构 modal 外壳、内容分组、输入控件样式、底部工具条)
    -   `components/AuthModal.tsx` (统一 modal 外壳、表单样式、按钮样式)
    -   `components/AccountPanel.tsx` (重构卡片样式、功能区布局、按钮样式)

---

### Fix Record - 2025-01-27

-   **Problem Description:** 翻译字幕时出现错误：`Translation API error: 400`，导致翻译功能无法正常工作。
-   **Root Cause:** 在 `translationService.ts` 中，当使用代理模式（`useProxy`）时，发送给 `/api/proxy` 的请求格式不正确。代码发送的是 `{ messages: [{ role: 'user', content: prompt }] }`，但代理 API 期望的格式是 `{ provider: 'gemini', contents: [{ parts: [{ text: prompt }] }] }`。缺少 `provider` 和 `contents` 字段，导致代理 API 返回 400 错误。
-   **Solution:** 
    1. 修复代理请求格式：从 `getEffectiveSettings()` 获取设置，构建正确的 payload，包含 `provider` 和 `contents` 字段
    2. 使用 Gemini 格式的 `contents` 结构：`[{ parts: [{ text: prompt }] }]`
    3. 改进响应解析：从 `data.candidates[0].content.parts` 中提取文本，兼容不同的响应格式
    4. 增强错误处理：从响应 JSON 中提取详细的错误信息，提供更友好的错误提示
-   **Impact Scope:**
    -   `services/translationService.ts` (修复代理请求格式、响应解析和错误处理)

---

### Fix Record - 2025-01-27

-   **Problem Description:** 
    1. 翻译字幕时无法选择翻译语言，只能自动检测并翻译
    2. 点击翻译字幕时，见解会同步生成，导致翻译和见解生成同时进行
-   **Root Cause:** 
    1. `handleTranslateSubtitles` 函数自动检测语言并选择目标语言，没有提供用户选择界面
    2. 翻译操作可能触发了某些自动生成见解的逻辑（虽然代码中没有直接看到，但用户反馈确实存在）
-   **Solution:** 
    1. 添加翻译语言选择模态框：点击翻译按钮时显示语言选择对话框，用户可以选择简体中文、繁体中文或英语
    2. 添加 `showTranslationLanguageModal` 状态来控制模态框显示
    3. 修改 `handleTranslateSubtitles` 函数，接受可选的 `targetLang` 参数，如果未提供则显示选择对话框
    4. 添加 `isTranslationFromUser` 状态标记，用于标识这是用户主动触发的翻译操作（虽然当前代码中没有自动生成见解的逻辑，但添加此标记以备将来使用）
    5. 添加翻译相关的国际化文本：`subtitlesAlreadyTranslated` 和 `translationComplete`
-   **Impact Scope:**
    -   `components/VideoDetail.tsx` (添加语言选择模态框、修改翻译函数、添加状态管理)
    -   `i18n/locales/zh.ts` (添加翻译相关文本)
    -   `i18n/locales/en.ts` (添加翻译相关文本)

---

### Fix Record - 2025-01-27

-   **Problem Description:** 
    1. 设置面板和登录面板的背景需要添加透明毛玻璃风格，提升视觉效果
    2. 需要在登录面板中添加 Linux.do 登录方式
-   **Root Cause:** 
    1. 当前背景使用 `bg-black/40 backdrop-blur-sm`，毛玻璃效果不够明显
    2. AuthModal 中只有 Google 和 GitHub 两种 OAuth 登录方式，缺少 Linux.do 选项
-   **Solution:** 
    1. **增强毛玻璃效果**：
       - 将背景从 `bg-black/40 backdrop-blur-sm` 改为 `bg-black/20 backdrop-blur-md`，降低背景不透明度，增强模糊效果
       - 将模态框背景从 `bg-white` 改为 `bg-white/95 backdrop-blur-xl`，添加半透明和毛玻璃效果
       - 添加 `border border-white/20` 边框，增强层次感
    2. **添加 Linux.do 登录方式**：
       - 在 `AuthModal.tsx` 中添加 `handleLinuxDoSignIn` 函数，处理 Linux.do OAuth 登录
       - 将 OAuth 按钮网格从 `grid-cols-2` 改为 `grid-cols-3`，添加 Linux.do 按钮
       - 添加 Linux.do 图标（使用信息图标样式）
       - 在 `i18n/locales/zh.ts` 和 `i18n/locales/en.ts` 中添加相关翻译键：`linuxDo`、`linuxDoLogin`、`linuxDoLoginInitiated`
-   **Impact Scope:**
    -   `components/SettingsModal.tsx` (增强背景毛玻璃效果)
    -   `components/AuthModal.tsx` (增强背景毛玻璃效果、添加 Linux.do 登录按钮和处理函数)
    -   `i18n/locales/zh.ts` (添加 Linux.do 相关翻译)
    -   `i18n/locales/en.ts` (添加 Linux.do 相关翻译)

---

### Fix Record - 2025-01-27 (续)

-   **Problem Description:** 更新 Linux.do OAuth 登录实现，使用正确的 OAuth 端点
-   **Root Cause:** 之前使用的是示例链接，需要替换为实际的 Linux.do OAuth 端点
-   **Solution:** 
    1. **创建 Linux.do OAuth 服务** (`services/linuxDoAuthService.ts`)：
       - 实现完整的 OAuth 2.0 PKCE 流程
       - 使用正确的端点：`https://connect.linux.do/oauth2/authorize`、`https://connect.linux.do/oauth2/token`、`https://connect.linux.do/api/user`
       - 实现 `buildLinuxDoAuthUrl` 函数构建授权 URL（包含 state、code_challenge 等参数）
       - 实现 `exchangeCodeForToken` 函数交换授权码获取访问令牌
       - 实现 `getLinuxDoUserInfo` 函数获取用户信息
       - 实现 `verifyState` 函数验证 state 参数防止 CSRF 攻击
    2. **更新 AuthModal**：
       - 导入并使用 `buildLinuxDoAuthUrl` 函数
       - 修改 `handleLinuxDoSignIn` 为异步函数，构建正确的授权 URL
       - 使用 `window.location.href` 跳转到授权页面（标准 OAuth 流程）
    3. **更新 AccountPanel**：
       - 同样使用新的 `buildLinuxDoAuthUrl` 函数
       - 统一 OAuth 登录流程
    4. **添加 OAuth 回调处理**（`App.tsx`）：
       - 在 `useEffect` 中检测 URL 参数中的 `code` 和 `state`
       - 验证 state 参数
       - 交换授权码获取令牌
       - 获取用户信息
       - 清理 URL 参数
       - 显示成功/错误消息
    5. **环境变量支持**：
       - 支持通过 `VITE_LINUXDO_CLIENT_ID` 环境变量配置 Client ID
    6. **创建配置文档**：
       - 创建 `LINUXDO_OAUTH_SETUP.md` 详细说明配置步骤
-   **Impact Scope:**
    -   `services/linuxDoAuthService.ts` (新建文件，Linux.do OAuth 服务)
    -   `components/AuthModal.tsx` (更新 Linux.do 登录处理)
    -   `components/AccountPanel.tsx` (更新 Linux.do 登录处理)
    -   `App.tsx` (添加 OAuth 回调处理逻辑)
    -   `LINUXDO_OAUTH_SETUP.md` (新建文件，配置文档)

**注意**：使用前需要在 Linux.do 注册 OAuth 应用，获取 Client ID，并配置环境变量 `VITE_LINUXDO_CLIENT_ID`。回调 URL 需要配置为：`{你的域名}/auth/linuxdo/callback`

---

### Fix Record - 2025-01-27 (续2)

-   **Problem Description:** 更新 Linux.do OAuth 服务，使其能够从 Supabase 数据库读取客户端 ID 和密钥，而不是仅从环境变量读取
-   **Root Cause:** 用户已经在 Supabase 数据库中配置了 Linux.do 的客户端 ID 和密钥，但代码只支持从环境变量读取
-   **Solution:** 
    1. **更新 `linuxDoAuthService.ts`**：
       - 添加 `getLinuxDoConfig` 异步函数，支持从多个来源读取配置：
         - 优先从 Supabase 数据库的 `oauth_config` 表读取（结构：`provider='linuxdo'`, `key='client_id'/'client_secret'`）
         - 备选从 `app_config` 表读取（结构：`key='linuxdo_client_id'/'linuxdo_client_secret'`）
         - 最后回退到环境变量 `VITE_LINUXDO_CLIENT_ID`
       - 添加配置缓存机制，避免重复查询数据库
       - 将 `getClientId` 和 `getClientSecret` 改为异步函数
       - 更新 `buildLinuxDoAuthUrl` 和 `exchangeCodeForToken` 以支持异步配置读取
       - 在 token 交换时，如果存在 client_secret，会自动添加到请求中
    2. **创建数据库迁移文件**：
       - 创建 `supabase/migrations/create_oauth_config_table.sql`
       - 定义 `oauth_config` 表结构，支持存储多个 OAuth provider 的配置
       - 包含 RLS（Row Level Security）策略
       - 提供示例 INSERT 语句
    3. **更新配置文档**：
       - 更新 `LINUXDO_OAUTH_SETUP.md`，添加从 Supabase 数据库配置的详细说明
       - 说明两种配置表结构的使用方法
       - 保留环境变量配置作为备选方案
-   **Impact Scope:**
    -   `services/linuxDoAuthService.ts` (更新配置读取逻辑，支持从数据库读取)
    -   `supabase/migrations/create_oauth_config_table.sql` (新建文件，创建配置表)
    -   `LINUXDO_OAUTH_SETUP.md` (更新配置说明)

**配置方式**：
1. **推荐**：在 Supabase 数据库中创建 `oauth_config` 表，并插入配置数据
2. **备选**：使用环境变量 `VITE_LINUXDO_CLIENT_ID`

---

### Fix Record - 2025-01-27 (续3)

-   **Problem Description:** Linux.do 登录后，用户信息未能保存到 profiles 表中
-   **Root Cause:** OAuth 回调处理中只获取了用户信息，但没有实现保存到数据库的逻辑
-   **Solution:** 
    1. **创建数据库迁移文件** (`supabase/migrations/add_linuxdo_fields_to_profiles.sql`)：
       - 在 `profiles` 表中添加 Linux.do 相关字段：
         - `linuxdo_user_id` (text) - Linux.do 用户 ID
         - `linuxdo_username` (text) - Linux.do 用户名
         - `linuxdo_access_token` (text) - OAuth 访问令牌
         - `linuxdo_token_expires_at` (timestamptz) - 令牌过期时间
         - `linuxdo_user_data` (jsonb) - 完整的 Linux.do 用户信息（JSON 格式）
       - 创建索引以优化查询性能
    2. **更新 Profile 接口** (`services/authService.ts`)：
       - 在 `Profile` 接口中添加 Linux.do 相关字段的类型定义
    3. **实现保存逻辑** (`App.tsx`)：
       - 在 OAuth 回调处理中，获取到用户信息后：
         - 如果用户已登录 Supabase：直接将 Linux.do 信息保存到 profiles 表
         - 如果用户未登录：将信息保存到 localStorage，等待用户登录后迁移
       - 添加数据迁移功能：当用户登录 Supabase 后，自动检查 localStorage 中是否有 Linux.do 数据，如果有则迁移到 profiles 表
       - 处理 token 过期时间计算
       - 清理 undefined 值，避免数据库错误
    4. **错误处理**：
       - 添加 try-catch 确保保存失败不会影响 OAuth 流程
       - 添加控制台日志便于调试
-   **Impact Scope:**
    -   `supabase/migrations/add_linuxdo_fields_to_profiles.sql` (新建文件，数据库迁移)
    -   `services/authService.ts` (更新 Profile 接口)
    -   `App.tsx` (实现保存逻辑和数据迁移)

**使用说明**：
1. 在 Supabase SQL Editor 中执行迁移文件 `add_linuxdo_fields_to_profiles.sql`
2. Linux.do 登录后，如果用户已登录 Supabase，信息会自动保存到 profiles 表
3. 如果用户未登录，信息会保存在 localStorage，登录后自动迁移

---

### Fix Record - 2025-01-27 (续4)

-   **Problem Description:** Linux.do 的 logo/头像获取不到
-   **Root Cause:** 代码中没有提取和保存 Linux.do API 返回的用户头像 URL
-   **Solution:** 
    1. **更新数据库迁移** (`supabase/migrations/add_linuxdo_fields_to_profiles.sql`)：
       - 添加 `linuxdo_avatar_url` 字段用于存储用户头像 URL
    2. **更新 Profile 接口** (`services/authService.ts`)：
       - 添加 `linuxdo_avatar_url` 字段类型定义
    3. **增强头像提取逻辑** (`App.tsx`)：
       - 在保存用户信息时，尝试从多个可能的字段名提取头像 URL：
         - `avatar_url`, `avatar`, `logo`, `picture`, `avatarUrl`, `profile_image_url`, `profile_picture`, `image`, `photo`, `thumbnail`
       - 添加详细的调试日志，输出所有可能的头像字段值，便于排查问题
    4. **更新 UI 显示** (`components/AccountPanel.tsx`)：
       - 在 Linux.do 登录区域显示用户头像（如果有）
       - 如果没有头像，显示默认的终端图标
       - 显示已绑定的用户名
       - 根据 profile 中的 `linuxdo_user_id` 自动更新连接状态
    5. **更新按钮图标** (`components/AuthModal.tsx`)：
       - 将 Linux.do 登录按钮的图标改为更合适的终端图标
-   **Impact Scope:**
    -   `supabase/migrations/add_linuxdo_fields_to_profiles.sql` (添加头像字段)
    -   `services/authService.ts` (更新 Profile 接口)
    -   `App.tsx` (增强头像提取逻辑和调试日志)
    -   `components/AccountPanel.tsx` (显示头像和用户名)
    -   `components/AuthModal.tsx` (更新按钮图标)

**调试方法**：
1. 完成 Linux.do OAuth 登录后，打开浏览器控制台（F12）
2. 查看 "Linux.do avatar fields check" 日志，可以看到所有可能的头像字段值
3. 如果某个字段有值但代码没有提取到，可以告诉我具体的字段名，我会更新代码

---

### Fix Record - 2025-01-27 (续5)

-   **Problem Description:** Google 和 GitHub 登录后，用户头像未能获取并显示
-   **Root Cause:** 
    1. Supabase OAuth 登录时，头像信息存储在 `auth.users` 表的 `raw_user_meta_data` 中，但可能使用不同的字段名（Google 用 `picture`，GitHub 用 `avatar_url`）
    2. 数据库触发器 `handle_new_user()` 只检查 `avatar_url` 字段
    3. 现有用户可能没有同步头像到 profile
    4. UI 中没有显示头像
-   **Solution:** 
    1. **更新数据库触发器** (`supabase/migrations/20251112021718_create_auth_and_sync_tables.sql`)：
       - 修改 `handle_new_user()` 函数，使用 `COALESCE` 检查多个可能的头像字段：`avatar_url`, `picture`, `avatar`
       - 同时检查 `full_name` 和 `name` 字段
    2. **创建头像同步迁移** (`supabase/migrations/update_handle_new_user_for_oauth_avatars.sql`)：
       - 更新 `handle_new_user()` 函数以支持多个头像字段
       - 创建 `sync_oauth_avatars()` 函数，用于为现有用户同步头像
       - 自动执行同步函数，更新已有用户的头像
    3. **添加头像同步服务** (`services/authService.ts`)：
       - 添加 `syncAvatarFromProvider()` 方法，从 OAuth provider 的用户元数据中提取头像
       - 如果 profile 中没有头像，但 user 对象中有，则自动更新 profile
       - 支持 Google (`picture`) 和 GitHub (`avatar_url`) 的头像字段
    4. **更新 App.tsx**：
       - 在用户登录时自动调用 `syncAvatarFromProvider()` 同步头像
       - 在 `onAuthStateChange` 回调中也同步头像
    5. **更新 AccountPanel UI** (`components/AccountPanel.tsx`)：
       - 在账号信息区域显示用户头像（如果有）
       - 如果头像加载失败，自动回退到显示首字母
       - 在加载 profile 时，如果发现没有头像，自动从 OAuth provider 同步
-   **Impact Scope:**
    -   `supabase/migrations/20251112021718_create_auth_and_sync_tables.sql` (更新触发器函数)
    -   `supabase/migrations/update_handle_new_user_for_oauth_avatars.sql` (新建文件，同步现有用户头像)
    -   `services/authService.ts` (添加头像同步方法)
    -   `App.tsx` (在登录时同步头像)
    -   `components/AccountPanel.tsx` (显示头像)

**使用说明**：
1. **新用户**：使用 Google/GitHub 登录时，头像会自动提取并保存到 profile
2. **现有用户**：执行 `update_handle_new_user_for_oauth_avatars.sql` 迁移文件，会自动为现有用户同步头像
3. **手动同步**：如果头像仍未显示，刷新页面或重新登录即可自动同步

---

### Fix Record - 2025-01-27 (续7)

-   **Problem Description:** 全站没有统一的 Toast 和 Modal 体系，导致任何局部样式改动都很难"传染"到全局，代码中存在大量重复的 `fixed top-`、`bg-black/50`、`shadow-2xl` 等样式
-   **Root Cause:** 
    1. 每个组件都自己实现错误提示 UI（`fixed top-5 right-5` + 自定义样式）
    2. 每个 Modal 都自己实现遮罩和容器（`fixed inset-0` + `bg-black/50` + 自定义样式）
    3. 没有统一的视觉 Token 和组件抽象
-   **Solution:** 
    1. **创建全局 Toast 体系**：
       - `hooks/useToastStore.ts`：使用 React Context + useState 实现 Toast 状态管理
       - `components/ui/ToastHost.tsx`：统一 Toast UI 渲染容器（右上角、24px 圆角、slate-900/90 背景）
       - `toast.success/error/info()` API：业务代码统一调用接口
    2. **创建全局 Modal 体系**：
       - `components/ui/BaseModal.tsx`：统一 Modal 外壳组件
       - 统一视觉规范：32px 圆角、统一遮罩、ESC 关闭、点击遮罩关闭
       - 提供 `BaseModal.Header`、`BaseModal.Body`、`BaseModal.Footer` 子组件
    3. **迁移 App.tsx**：
       - 添加 `ToastProvider` 包裹 `LanguageProvider`
       - 添加 `<ToastHost />` 到 `AppContent`
       - 删除 `error` 状态和错误提示 UI
       - 所有 `setError()` 调用改为 `toast.error()`
    4. **迁移 AccountPanel**：
       - 删除 `syncMessage` 状态和 UI 显示
       - 所有 `setSyncMessage()` 调用改为 `toast.success/error()`
    5. **迁移 FeedbackModal**：
       - 使用 `BaseModal` 替换自定义遮罩和容器
       - 统一按钮样式为 `rounded-full`
    6. **迁移 AuthModal**：
       - 使用 `BaseModal` 替换自定义遮罩和容器
       - 删除 `error` 和 `message` 状态，改为使用 `toast`
       - 删除 `if (!isOpen) return null;`，改用 BaseModal 的 `open` prop
    7. **迁移 SettingsModal**：
       - 使用 `BaseModal` 替换自定义遮罩和容器
       - 删除 `testState` 状态，测试结果改为使用 `toast`
       - 统一按钮样式
-   **Impact Scope:**
    -   `hooks/useToastStore.ts` (新建)
    -   `components/ui/ToastHost.tsx` (新建)
    -   `components/ui/BaseModal.tsx` (新建)
    -   `App.tsx` (集成 ToastProvider/ToastHost，迁移错误提示)
    -   `components/AccountPanel.tsx` (迁移同步消息到 Toast)
    -   `components/FeedbackModal.tsx` (迁移到 BaseModal)
    -   `components/AuthModal.tsx` (迁移到 BaseModal，错误提示改为 Toast)
    -   `components/SettingsModal.tsx` (迁移到 BaseModal，测试提示改为 Toast)
    -   `@docs/TOAST_MODAL_REFACTOR_GUIDE.md` (新建，完整改造指南)
    -   `@docs/MIGRATION_EXAMPLES.md` (新建，迁移示例)
    -   `@docs/QUICK_START_TOAST_MODAL.md` (新建，快速开始指南)

**使用说明**：
1. **Toast API**：
   ```tsx
   import { toast } from './hooks/useToastStore';
   toast.success({ title: '成功', description: '操作完成' });
   toast.error({ title: '错误', description: '操作失败' });
   toast.info({ title: '提示', description: '正在处理...' });
   ```
2. **BaseModal API**：
   ```tsx
   import { BaseModal } from './components/ui/BaseModal';
   <BaseModal open={isOpen} onOpenChange={setIsOpen} size="md">
     <BaseModal.Header title="标题" subtitle="副标题" />
     <BaseModal.Body>内容</BaseModal.Body>
     <BaseModal.Footer>按钮</BaseModal.Footer>
   </BaseModal>
   ```
3. **统一视觉规范**：
   - Toast：右上角、24px 圆角、slate-900/90 背景、最多同时显示 2 条
   - Modal：32px 圆角、统一遮罩、ESC 关闭、点击遮罩关闭

**效果**：
- 所有错误和成功提示现在都通过统一的 Toast 显示
- 所有 Modal 都使用统一的 BaseModal 外壳
- 任何 Toast 或 Modal 的样式改动都会自动应用到全站
- 代码更简洁，没有重复的样式代码

---

### Fix Record - 2025-01-27 (续8)

-   **Problem Description:** 截图功能无法自动复制到剪贴板，用户需要手动保存截图
-   **Root Cause:** 
    `handleScreenshot` 函数只将截图保存为 dataUrl 并显示在聊天面板，没有使用 Clipboard API 复制到剪贴板
-   **Solution:** 
    1. **修改 `handleScreenshot` 函数** (`components/VideoDetail.tsx`)：
       - 将函数改为 `async`
       - 在生成截图后，使用 `canvas.toBlob()` 将 canvas 转换为 Blob
       - 使用 `navigator.clipboard.write()` 和 `ClipboardItem` 将图片复制到剪贴板
       - 复制成功时显示成功 Toast 提示
       - 如果 Clipboard API 失败（权限问题或浏览器不支持），显示信息提示，说明截图已保存到聊天面板
    2. **添加翻译键**：
       - `i18n/locales/zh.ts`：添加 `screenshotCopied`、`screenshotSaved`、`screenshotAvailableInChat`
       - `i18n/locales/en.ts`：添加对应的英文翻译
    3. **导入 toast**：
       - 在 `VideoDetail.tsx` 顶部导入 `toast` 用于显示提示
-   **Impact Scope:**
    -   `components/VideoDetail.tsx` (修改 `handleScreenshot` 函数，添加剪贴板复制功能)
    -   `i18n/locales/zh.ts` (添加截图相关翻译键)
    -   `i18n/locales/en.ts` (添加截图相关翻译键)

**使用说明**：
1. 点击视频播放器上的 "Screenshot" 按钮
2. 截图会自动复制到剪贴板
3. 显示成功提示："截图已复制到剪贴板"
4. 如果复制失败（权限或浏览器不支持），会显示："截图已保存，可在聊天面板中使用"
5. 截图同时会显示在聊天面板中，可用于 AI 对话

**技术细节**：
- 使用 `ClipboardItem` API 支持图片格式复制
- 使用 `canvas.toBlob()` 将 canvas 转换为 Blob 对象
- 错误处理：如果 Clipboard API 不可用，功能降级为仅保存到聊天面板
- 支持中英文双语提示

---

### Fix Record - 2025-01-27 (续9)

-   **Problem Description:** 笔记面板 UI 缺乏动态感和交互反馈，视觉上显得平淡
-   **Root Cause:** 
    原有的 NotesPanel 使用简单的 textarea 和静态状态显示，缺乏视觉层次和交互反馈
-   **Solution:** 
    对 NotesPanel 进行了全面的 UI 改进，添加了动态效果和交互反馈，同时保持原有数据流和保存机制不变：
    
    1. **自动保存时间线视觉**：
       - 添加了顶部进度条，在 `typing → saving → saved` 状态间做动画
       - typing：灰色 30% 宽，淡淡闪烁
       - saving：蓝色条缓慢走到 100%
       - saved：条收缩并淡出
    
    2. **文本区便签风格**：
       - 背景改为 `bg-slate-50/60`
       - 删除边框，改为 `ring-1 ring-slate-200`
       - 圆角改为 `rounded-2xl`
       - 行距增大：`leading-7`
       - 字体优化：`text-[15px]`，`font-normal`
    
    3. **输入时呼吸感阴影**：
       - 当 `status === 'typing'` 时，阴影从 `shadow-sm` → `shadow-md` 动态过渡
       - 保存后阴影缓慢收回
    
    4. **顶部工具栏增强**：
       - 添加"添加时间戳笔记"按钮（占位功能，将来可获取视频播放时间）
       - 添加折叠/展开按钮
       - 添加清空按钮
       - 所有按钮统一风格：`bg-white/60 border border-slate-200 rounded-xl`
    
    5. **保存状态动效**：
       - typing：三个点上下跳动动画
       - saving：圆环旋转动画（Loader2 图标）
       - saved：对勾淡入淡出动画（CheckCircle2 图标）
    
    6. **文本排版提示**：
       - 用户首次输入时显示提示气泡
       - 提示内容："输入双回车可分段 · 输入 `-` 可创建项目符号"
       - 2 秒后自动消失，带淡入淡出动画
    
    7. **滚动边缘光晕**：
       - 当 textarea 滚动时，顶部/底部出现渐变阴影
       - 类似 Notion / Apple Notes 的滚动溢出效果
    
    8. **卡片风格容器**：
       - 外层容器改为 `rounded-3xl bg-white/70 shadow-sm backdrop-blur-md`
       - 与整体设计风格统一
    
    9. **折叠功能**：
       - 添加折叠/展开功能，折叠时只显示标题和展开按钮
    
    10. **状态自动管理**：
        - saved 状态 2 秒后自动切换回 idle
        - 优化状态显示逻辑
-   **Impact Scope:**
    -   `components/NotesPanel.tsx` (全面重构 UI，添加动态效果和交互反馈)
    -   导入 `lucide-react` 图标组件：`Download`, `ChevronDown`, `ChevronUp`, `Trash2`, `Plus`, `CheckCircle2`, `Loader2`

**视觉效果**：
- 笔记面板现在具有清晰的视觉层次和动态反馈
- 自动保存进度条提供即时反馈
- 输入时的阴影动画增加呼吸感
- 滚动边缘光晕提升专业感
- 所有交互都有平滑的过渡动画

**技术细节**：
- 使用 `useState` 管理 UI 状态（折叠、提示显示、滚动状态）
- 使用 `useRef` 引用 textarea 和容器元素
- 使用 `useEffect` 管理提示显示和状态自动切换
- 使用 Tailwind CSS 类实现所有动画效果
- 保持原有的 debounced save 机制不变

---

### Fix Record - 2025-01-27 (续10)

-   **Problem Description:** 
    1. 时间戳获取有问题，无法获取当前视频播放时间
    2. 需要添加预览模式，预览模式下时间戳可点击跳转视频
-   **Root Cause:** 
    1. `handleAddTimestampNote` 函数使用硬编码的 `'00:00'` 占位符，没有获取实际的视频播放时间
    2. NotesPanel 没有预览模式，无法查看渲染后的 Markdown 笔记，时间戳无法点击跳转
-   **Solution:** 
    1. **修复时间戳获取**：
       - 修改 `NotesPanelProps` 接口，添加 `currentTime?: number` 和 `onSeekTo?: (timeInSeconds: number) => void` 属性
       - 在 `VideoDetail.tsx` 中传递 `currentTime` 和 `handleSeekTo` 给 `NotesPanel`
       - 修改 `handleAddTimestampNote` 函数，使用传入的 `currentTime` 获取当前视频播放时间
       - 根据视频时长选择合适的时间戳格式：
         - 小于1小时：使用 `MM:SS` 格式
         - 大于等于1小时：使用 `HH:MM:SS` 格式
       - 时间戳按钮的 tooltip 显示当前时间
    
    2. **添加预览模式**：
       - 添加 `isPreviewMode` 状态管理预览/编辑模式切换
       - 添加预览/编辑切换按钮（使用 `Eye` 和 `Edit` 图标）
       - 在预览模式下：
         - 使用 `MarkdownRenderer` 组件渲染笔记内容
         - 时间戳可点击，点击后调用 `onSeekTo` 跳转到对应时间
         - 保持滚动边缘光晕效果
       - 在编辑模式下：
         - 保持原有的 textarea 输入
         - 时间戳按钮仅在编辑模式显示
       - 两种模式共享相同的样式和滚动处理逻辑
-   **Impact Scope:**
    -   `components/NotesPanel.tsx` (添加预览模式、修复时间戳获取、添加 MarkdownRenderer 集成)
    -   `components/VideoDetail.tsx` (传递 currentTime 和 handleSeekTo 给 NotesPanel)
    -   导入 `formatTimestamp` 从 `utils/helpers`
    -   导入 `Eye`, `Edit` 图标从 `lucide-react`
    -   导入 `MarkdownRenderer` 组件

**功能说明**：
1. **时间戳获取**：
   - 点击"时间戳"按钮时，自动获取当前视频播放时间
   - 时间戳格式根据视频时长自动选择（MM:SS 或 HH:MM:SS）
   - 按钮 tooltip 显示当前时间，方便用户确认

2. **预览模式**：
   - 点击"预览"按钮切换到预览模式
   - 预览模式下笔记以 Markdown 格式渲染，支持基本 Markdown 语法
   - 时间戳 `[MM:SS]` 或 `[HH:MM:SS]` 格式可点击
   - 点击时间戳后，视频自动跳转到对应时间点
   - 预览模式下可以查看渲染效果，编辑模式下可以编辑内容

**技术细节**：
- 使用 `formatTimestamp` 函数格式化时间戳
- 时间戳格式与 `MarkdownRenderer` 的 `timestampRegex` 兼容
- 预览模式使用 `MarkdownRenderer` 组件，支持时间戳点击回调
- 保持原有的自动保存机制和所有 UI 改进

---

### Fix Record - 2025-01-27 (续11)

-   **Problem Description:** 
    1. Linux.do OAuth 登录时显示 `invalid_request` 错误
    2. Linux.do 账户存储方式有问题，Linux.do 账户应该可以独立注册，不是非要绑定其他账户才能注册
-   **Root Cause:** 
    1. `redirect_uri` 参数不匹配：代码中使用的 redirect_uri 与在 Linux.do 注册应用时填写的回调 URL 不一致
    2. 存储逻辑问题：当前实现要求用户必须先有 Supabase 账户才能保存 Linux.do 信息，不支持独立 Linux.do 注册
-   **Solution:** 
    1. **修复 OAuth redirect_uri 问题**：
       - 修改 `buildLinuxDoAuthUrl` 函数，规范化 `redirect_uri`（移除尾部斜杠）
       - 在 `sessionStorage` 中存储 `redirect_uri`，确保授权请求和 token 交换使用相同的值
       - 修改 `AccountPanel.tsx` 和 `AuthModal.tsx`，使用当前页面的完整路径 `${window.location.origin}${window.location.pathname}` 而不是硬编码的 `/auth/linuxdo/callback`
       - 在 `App.tsx` 的回调处理中，从 `sessionStorage` 读取存储的 `redirect_uri`
       - 添加调试日志，方便排查问题
    
    2. **支持独立 Linux.do 注册**：
       - 在 `authService.ts` 中添加 `findOrCreateProfileByLinuxDoId` 方法：
         - 通过 `linuxdo_user_id` 查找已存在的 profile（支持之前绑定过的用户）
         - 如果找到，更新 profile 信息
         - 如果未找到，返回 null（由调用者处理）
       - 添加 `getProfileByLinuxDoId` 方法，用于通过 Linux.do 用户 ID 查询 profile
       - 修改 `App.tsx` 中的 OAuth 回调处理逻辑：
         - 如果用户已登录 Supabase：直接更新 profile
         - 如果用户未登录：先尝试通过 `linuxdo_user_id` 查找已存在的 profile
           - 如果找到：更新 profile 的 token 信息（支持独立 Linux.do 登录）
           - 如果未找到：存储到 localStorage，等待用户创建 Supabase 账户后迁移
       - 这样支持了两种场景：
         - 用户先注册 Supabase，后绑定 Linux.do
         - 用户先绑定 Linux.do，后注册 Supabase（通过 localStorage 迁移）
         - 用户仅使用 Linux.do 登录（如果之前已经绑定过）
-   **Impact Scope:**
    -   `services/linuxDoAuthService.ts` (规范化 redirect_uri，添加调试日志)
    -   `components/AccountPanel.tsx` (修改 redirect_uri 构建逻辑)
    -   `components/AuthModal.tsx` (修改 redirect_uri 构建逻辑)
    -   `App.tsx` (修改回调处理，支持通过 linuxdo_user_id 查找 profile)
    -   `services/authService.ts` (添加 `findOrCreateProfileByLinuxDoId` 和 `getProfileByLinuxDoId` 方法)

**重要提示**：
1. **redirect_uri 必须完全匹配**：
   - 在 Linux.do 注册 OAuth 应用时，回调 URL 必须填写为：`https://your-domain.com/`（或你的实际应用路径）
   - 代码中使用的 `redirect_uri` 必须与注册时填写的完全一致（包括协议、域名、路径、尾部斜杠等）

2. **独立 Linux.do 注册的限制**：
   - 由于 `profiles` 表要求 `id` 必须是 `auth.users(id)` 的外键，完全独立的 Linux.do 注册需要先创建 Supabase 账户
   - 当前实现支持：
     - 用户先绑定 Linux.do，后注册 Supabase（通过 localStorage 迁移）
     - 用户先注册 Supabase，后绑定 Linux.do
     - 如果用户之前已经绑定过 Linux.do，可以通过 `linuxdo_user_id` 找到对应的 profile 并登录

**技术细节**：
- 使用 `sessionStorage` 存储 `redirect_uri`，确保授权和 token 交换使用相同的值
- 规范化 `redirect_uri`：移除尾部斜杠，避免匹配问题
- 通过 `linuxdo_user_id` 索引快速查找已存在的 profile
- 保持向后兼容：如果找不到 profile，降级到 localStorage 存储

---

### Fix Record - 2025-01-27 (续12)

-   **Problem Description:** Linux.do 账户应该可以有独立的 profiles 的 id，不需要依赖 Supabase auth.users
-   **Root Cause:** 
    当前 `profiles` 表结构要求 `id` 字段必须是 `auth.users(id)` 的外键，这意味着必须先有 Supabase 用户才能创建 profile，不支持完全独立的 Linux.do 注册
-   **Solution:** 
    修改数据库结构，使 `profiles` 表支持独立的 Linux.do 账户：
    
    1. **创建数据库迁移文件** (`supabase/migrations/modify_profiles_for_independent_linuxdo.sql`)：
       - 添加 `auth_user_id` 字段：可选的外键，指向 `auth.users(id)`（对于 Supabase 用户）
       - 添加 `is_linuxdo_only` 字段：标记是否为仅 Linux.do 账户（无 Supabase 账户）
       - 移除 `profiles.id` 的外键约束，允许独立的 UUID
       - 更新现有 profile：将 `auth_user_id` 设置为 `id`（保持向后兼容）
       - 更新 RLS 策略：
         - Supabase 用户：通过 `auth_user_id` 或 `id` 访问
         - Linux.do 用户：允许 anon 访问（应用层通过 `linuxdo_user_id` 过滤）
       - 创建 `create_linuxdo_profile` RPC 函数：使用 `SECURITY DEFINER` 绕过 RLS，创建独立的 Linux.do profile
    
    2. **更新 Profile 接口** (`services/authService.ts`)：
       - 添加 `auth_user_id?: string` 字段
       - 添加 `is_linuxdo_only?: boolean` 字段
    
    3. **更新 `findOrCreateProfileByLinuxDoId` 方法**：
       - 优先使用 `create_linuxdo_profile` RPC 函数创建独立的 profile
       - 如果 RPC 失败，降级到直接插入（如果 RLS 允许）
       - 创建的 profile 使用独立的 UUID，`auth_user_id` 为 NULL，`is_linuxdo_only` 为 true
    
    4. **创建索引**：
       - `idx_profiles_auth_user_id`：快速查找 Supabase 用户
       - `idx_profiles_linuxdo_user_id`：快速查找 Linux.do 用户
       - `idx_profiles_is_linuxdo_only`：快速查找仅 Linux.do 账户
-   **Impact Scope:**
    -   `supabase/migrations/modify_profiles_for_independent_linuxdo.sql` (新建文件，修改表结构和 RLS 策略)
    -   `services/authService.ts` (更新 Profile 接口，更新 `findOrCreateProfileByLinuxDoId` 方法)

**数据库结构变化**：
- **之前**：`profiles.id` 必须是 `auth.users(id)` 的外键
- **之后**：
  - `profiles.id` 可以是独立的 UUID（对于 Linux.do-only 账户）
  - `profiles.auth_user_id` 可选地指向 `auth.users(id)`（对于 Supabase 用户）
  - `profiles.is_linuxdo_only` 标记是否为仅 Linux.do 账户

**支持的场景**：
1. **Supabase 用户**：`id = auth_user_id`，`is_linuxdo_only = false`
2. **Linux.do-only 用户**：`id` 是独立的 UUID，`auth_user_id = NULL`，`is_linuxdo_only = true`
3. **混合用户**：先注册 Linux.do，后注册 Supabase（通过 `linuxdo_user_id` 关联）

**使用说明**：
1. 运行数据库迁移：在 Supabase Dashboard 的 SQL Editor 中执行 `modify_profiles_for_independent_linuxdo.sql`
2. Linux.do 用户现在可以独立注册，不需要先创建 Supabase 账户
3. 创建的 profile 使用独立的 UUID，完全独立于 Supabase auth 系统

**技术细节**：
- 使用 `SECURITY DEFINER` RPC 函数绕过 RLS，允许创建独立的 profile
- RLS 策略允许 anon 访问，但应用层通过 `linuxdo_user_id` 过滤确保安全性
- 保持向后兼容：现有 Supabase 用户的 profile 不受影响

---

### Fix Record - 2025-01-27

-   **Problem Description:** 字幕分析时出现 413 错误（Content Too Large），错误信息显示 `/api/proxy` 请求体过大，超过 Vercel 服务器函数的 4.5MB 限制。视频文件大小为 188.4MB，时长为 110.1 分钟。
-   **Root Cause:** 
    1. 音频提取后转换为 base64 编码，base64 会增加约 33% 的大小
    2. 加上 JSON 包装（provider、contents 等字段），最终请求体可能超过 4.5MB
    3. 对于长视频（>30分钟），即使提取前 30 分钟，音频文件仍然可能过大
    4. 没有在发送前检查请求大小，导致请求到达服务器后才被拒绝
-   **Solution:** 
    1. **在 `generateContentViaProxy` 和 `generateContentStreamViaProxy` 中添加请求大小检查**：
       - 在发送请求前计算请求体大小
       - 如果超过 4.0MB（留出 0.5MB 安全边距），提前抛出错误并提示用户
       - 添加详细的错误信息（中英文），说明限制和建议的解决方案
    
    2. **在 `generateSubtitlesStreaming` 中添加音频大小预估检查**：
       - 音频提取后，估算 base64 编码后的请求大小（音频大小 × 1.33 + JSON 开销 0.1MB）
       - 如果预估大小超过 4.0MB，提前抛出错误
       - 提供清晰的错误提示，建议使用更短的视频片段（<20分钟）或降低音频质量
    
    3. **优化 `extractAudioToBase64` 函数，动态调整最大提取时长**：
       - 根据视频文件大小动态调整最大提取时长：
         - 文件 > 500MB：最多提取 15 分钟
         - 文件 > 200MB：最多提取 20 分钟
         - 文件 > 100MB：最多提取 25 分钟
         - 默认：30 分钟
       - 对于超长视频（>60分钟），进一步减少提取时长
       - 添加警告日志，说明提取限制的原因
    
    4. **改进日志输出**：
       - 在代理请求时输出请求大小日志
       - 在音频提取后输出预估请求大小
       - 当音频较大时（>3MB）输出警告
-   **Impact Scope:**
    -   `services/geminiService.ts` (添加请求大小检查，优化错误处理)
    -   `utils/helpers.ts` (优化音频提取，动态调整提取时长)

**技术细节**：
- Vercel Serverless Functions 限制：4.5MB 请求体
- Base64 编码开销：约 33%
- 安全边距：0.5MB（实际限制 4.0MB）
- 音频大小估算公式：`音频大小(MB) × 1.33 + 0.1MB (JSON开销)`

**优化效果**：
- 对于 188.4MB、110.1 分钟的视频：
  - 之前：提取 30 分钟，可能超过 4.5MB 限制 → 413 错误
  - 现在：根据文件大小自动调整为提取 15-20 分钟，确保在限制内 → 成功处理

---

### Fix Record - 2025-01-27

-   **Problem Description:** Deepgram API 优先使用但遇到 CORS 错误。系统设计优先使用 Deepgram 服务生成字幕，但 Deepgram API 不支持从浏览器直接调用（CORS 限制），导致 `isDeepgramAvailable()` 和 `generateSubtitlesWithDeepgram()` 函数失败。
-   **Root Cause:** 
    1. Deepgram API (`https://api.deepgram.com`) 不支持 CORS，无法从浏览器直接调用
    2. `isDeepgramAvailable()` 函数尝试直接从浏览器调用 `/v1/projects` 端点验证 API key，遇到 CORS 错误
    3. `generateSubtitlesWithDeepgram()` 函数直接从浏览器调用 `/v1/listen` 端点，也会遇到 CORS 错误
    4. 没有代理 API 端点来处理 Deepgram 请求
-   **Solution:** 
    1. **创建 Deepgram 代理 API** (`api/deepgram-proxy.ts`)：
       - 创建服务器端代理端点，解决 CORS 问题
       - 支持 GET 请求用于 API key 验证（`/v1/projects`）
       - 支持 POST 请求用于音频/视频转录（`/v1/listen`）
       - 支持通过请求头 `X-Deepgram-API-Key` 传递用户 API key，或使用环境变量 `DEEPGRAM_API_KEY`
       - 添加 CORS 响应头，允许浏览器访问
       - 转发所有查询参数（model、language、smart_format 等）到 Deepgram API
    
    2. **修改 `isDeepgramAvailable()` 函数**：
       - 改为通过 `/api/deepgram-proxy` 代理端点验证 API key
       - 使用 GET 请求，通过 `X-Deepgram-API-Key` 请求头传递 API key
       - 移除 CORS 错误处理逻辑（不再需要，因为通过代理调用）
    
    3. **修改 `generateSubtitlesWithDeepgram()` 函数**：
       - 改为通过 `/api/deepgram-proxy` 代理端点调用转录 API
       - 将查询参数附加到代理 URL
       - 通过 `X-Deepgram-API-Key` 请求头传递 API key
       - 保持原有的文件上传和参数处理逻辑
-   **Impact Scope:**
    -   `api/deepgram-proxy.ts` (新建文件，Deepgram API 代理端点)
    -   `services/deepgramService.ts` (修改为通过代理调用，解决 CORS 问题)

**技术细节**：
- Deepgram API 使用 `Token` 认证（不是 `Bearer`）
- 代理支持用户 API key（通过请求头）和系统 API key（通过环境变量）
- 代理转发所有查询参数和请求体到 Deepgram API
- CORS 预检请求（OPTIONS）已处理

**优化效果**：
- 之前：直接从浏览器调用 Deepgram API → CORS 错误 → 无法使用 Deepgram
- 现在：通过服务器代理调用 → 无 CORS 问题 → 可以正常使用 Deepgram 优先服务

---

### Fix Record - 2025-01-27

-   **Problem Description:** Deepgram 密钥获取方式存在问题。用户将密钥存储在 Vercel 环境变量中，但服务器端代理无法正确读取。在 Vercel serverless functions 中，`VITE_` 前缀的环境变量不会暴露给服务器端代码。
-   **Root Cause:** 
    1. 客户端代码使用 `import.meta.env.VITE_DEEPGRAM_API_KEY` 获取密钥（正确）
    2. 服务器端代理尝试读取 `process.env.VITE_DEEPGRAM_API_KEY`，但在 Vercel serverless functions 中，`VITE_` 前缀的环境变量**不会**自动暴露给服务器端代码
    3. 代理代码还尝试读取 `process.env.VITE_DEEPGRAM_API_KEY` 作为备用，但这在服务器端始终是 `undefined`
    4. 虽然客户端会通过请求头传递密钥，但错误信息不够清晰，可能导致混淆
-   **Solution:** 
    1. **修复代理代码的密钥获取逻辑**：
       - 移除对 `process.env.VITE_DEEPGRAM_API_KEY` 的依赖（因为它在服务器端不可用）
       - 优先使用请求头 `X-Deepgram-API-Key`（客户端会自动传递）
       - 仅使用 `process.env.DEEPGRAM_API_KEY` 作为服务器端备用（不带 VITE_ 前缀）
       - 更新错误信息，说明密钥应该通过请求头传递（客户端会自动处理）
    
    2. **更新文档说明**：
       - 明确说明 `VITE_DEEPGRAM_API_KEY` 是必需的（客户端使用）
       - 说明 `DEEPGRAM_API_KEY` 是可选的（仅作为服务器端备用）
       - 解释为什么需要两个环境变量，以及它们的作用
       - 说明如果只设置 `VITE_DEEPGRAM_API_KEY`，系统也能正常工作（客户端会通过请求头传递）
-   **Impact Scope:**
    -   `api/deepgram-proxy.ts` (修复密钥获取逻辑，移除无效的 VITE_ 环境变量读取)
    -   `@docs/VERCEL_ENV_SETUP.md` (更新文档，说明环境变量的正确配置方式)

**技术细节**：
- Vercel 环境变量规则：
  - `VITE_` 前缀：仅在构建时注入到客户端代码，服务器端不可访问
  - 无前缀：可在服务器端访问（serverless functions）
- 密钥传递流程：
  1. 客户端从 `VITE_DEEPGRAM_API_KEY` 或用户设置获取密钥
  2. 通过 `X-Deepgram-API-Key` 请求头传递给代理
  3. 代理优先使用请求头中的密钥，如果没有则使用 `DEEPGRAM_API_KEY` 环境变量（备用）

**配置建议**：
- **最小配置**：只设置 `VITE_DEEPGRAM_API_KEY`（客户端会自动通过请求头传递）
- **完整配置**：同时设置 `VITE_DEEPGRAM_API_KEY` 和 `DEEPGRAM_API_KEY`（提供服务器端备用）

---

### Fix Record - 2025-01-27

-   **Problem Description:** 构建错误：在 `utils/helpers.ts` 中，`fileSizeMB` 变量被重复定义，导致 esbuild 构建失败。
-   **Root Cause:** 
    1. 在 `extractAudioToBase64` 函数中，第 73 行已经定义了 `const fileSizeMB`
    2. 在第 118 行又尝试用 `const` 重新定义同一个变量
    3. 这违反了 JavaScript 的块作用域规则，导致 "Cannot redeclare block-scoped variable" 错误
    4. 这是在之前的优化中，将 `fileSizeMB` 的定义移到了函数开头，但忘记删除后面的重复定义
-   **Solution:** 
    1. **删除重复的变量定义**：
       - 移除第 118 行的 `const fileSizeMB = videoFile.size / (1024 * 1024);`
       - 添加注释说明 `fileSizeMB` 已在上面定义（第 73 行）
       - 保持使用已定义的 `fileSizeMB` 变量
-   **Impact Scope:**
    -   `utils/helpers.ts` (删除重复的变量定义)

**技术细节**：
- JavaScript 块作用域规则：在同一作用域内，不能使用 `const` 或 `let` 重复声明同一个变量
- `fileSizeMB` 在第 73 行定义后，可以在整个 `video.onloadedmetadata` 回调函数中使用

---

### Fix Record - 2025-01-27

-   **Problem Description:** 视频分析时请求体过大（45.65MB），超过 Vercel 的 4.5MB 限制。错误信息显示 "Request too large: 45.65MB (limit: 4MB)"。
-   **Root Cause:** 
    1. `prepareAnalysisPayload` 函数检查帧的总大小，但限制设置为 15MB，远超过 Vercel 的 4.5MB 限制
    2. 检查的是原始 base64 帧数据大小，没有考虑 JSON 包装和请求体开销
    3. 帧的 JPEG 质量设置为 0.6，对于大量帧来说仍然太大
    4. 对于长视频，可能提取 360 帧，即使每帧压缩后也可能超过限制
-   **Solution:** 
    1. **降低帧大小限制** (`services/videoProcessingService.ts`)：
       - 将帧大小限制从 15MB 降低到 3.5MB
       - 添加请求大小估算：`estimatedRequestSizeMB = totalSizeMB + 0.1MB (JSON开销)`
       - 确保估算的请求大小不超过 3.5MB，以留出安全边距（Vercel 限制 4.5MB）
       - 更新日志输出，显示原始大小和估算的请求大小
    
    2. **降低 JPEG 压缩质量** (`utils/helpers.ts`)：
       - 将 JPEG 质量从 0.6 降低到 0.5
       - 添加注释说明降低质量是为了更好的压缩，特别是对于大量帧
       - 这可以显著减少每帧的大小，从而减少总请求大小
-   **Impact Scope:**
    -   `services/videoProcessingService.ts` (降低帧大小限制，添加请求大小估算)
    -   `utils/helpers.ts` (降低 JPEG 压缩质量)

**技术细节**：
- Vercel Serverless Functions 限制：4.5MB 请求体
- 帧数据已经是 base64 编码，不需要再次编码
- JSON 包装开销：约 0.1MB
- 安全边距：0.5MB（实际限制 4.0MB，帧数据限制 3.5MB）
- JPEG 质量 0.5 vs 0.6：可以减少约 20-30% 的文件大小

**优化效果**：
- 之前：帧大小限制 15MB → 实际请求可能 45.65MB → 超过限制 → 413 错误
- 现在：帧大小限制 3.5MB + 更低 JPEG 质量 → 实际请求 < 4MB → 成功处理

---

### Fix Record - 2025-01-27

-   **Problem Description:** 视频分析时，如果视频有音频，应该优先使用音频文件进行分析，而不是视频帧。音频文件比视频帧小得多，而且对于大多数分析任务（如总结、关键信息、主题），音频内容比视觉内容更重要。
-   **Root Cause:** 
    1. `prepareAnalysisPayload` 函数的逻辑是：如果有字幕使用字幕，否则直接提取视频帧
    2. 没有检查视频是否有音频轨道
    3. 没有优先使用音频进行分析的逻辑
    4. 视频帧数据量大（可能达到 45MB），而音频文件通常只有几 MB
-   **Solution:** 
    1. **修改 `prepareAnalysisPayload` 函数** (`services/videoProcessingService.ts`)：
       - 添加音频轨道检测：使用 `analyzeVideoMetadata` 检查视频是否有音频
       - 如果有音频，优先提取音频并用于分析
       - 添加音频大小检查，如果音频过大（超过 4MB 限制），降级到视频帧
       - 只有在没有音频或音频提取失败时，才使用视频帧作为后备方案
       - 更新返回类型，支持返回 `audioData`
    
    2. **修改 `analyzeVideo` 函数** (`services/geminiService.ts`)：
       - 添加 `audioData` 参数支持
       - 更新优先级：字幕文本 > 音频 > 视频帧
       - 当使用音频时，构建包含音频数据的请求内容
       - 更新错误信息，说明需要提供字幕、音频或帧之一
-   **Impact Scope:**
    -   `services/videoProcessingService.ts` (添加音频提取逻辑，优先使用音频)
    -   `services/geminiService.ts` (支持音频数据参数，更新分析逻辑)

**技术细节**：
- 优先级顺序：字幕文本（最小） > 音频（中等） > 视频帧（最大）
- 音频提取使用 `extractAudioToBase64`，与字幕生成使用相同的函数
- 音频大小检查：估算请求大小（音频大小 × 1.33 + 0.1MB），确保不超过 4MB
- 如果音频过大，自动降级到视频帧提取

**优化效果**：
- 之前：没有字幕 → 直接提取视频帧（可能 45MB） → 超过限制 → 413 错误
- 现在：没有字幕 → 检查音频 → 提取音频（通常 1-3MB） → 成功处理
- 对于有音频的视频，请求大小减少约 90-95%

---

### Fix Record - 2025-01-27

-   **Problem Description:** 实现对象存储直传架构，避免大文件通过 Vercel Serverless Functions 传输。当前方案（音频/视频帧）虽然减少了请求大小，但仍然受限于 4.5MB。更好的方案是前端直接上传到对象存储，后端只接收文件 URL。
-   **Root Cause:** 
    1. Vercel Serverless Functions 有 4.5MB 请求体限制
    2. 即使使用音频（1-3MB），对于超长视频仍然可能超过限制
    3. 视频帧虽然压缩后可能 < 4MB，但质量会下降
    4. 大文件不应该通过 serverless function 传输，这是架构层面的问题
-   **Solution:** 
    1. **创建获取上传凭证的 API** (`api/get-upload-url.ts`)：
       - 接收文件名、文件类型、文件大小（小请求，< 1KB）
       - 生成唯一的文件路径
       - 返回文件路径和上传方法
       - 使用 Supabase Storage 作为对象存储
    
    2. **创建处理视频的 API** (`api/process-video.ts`)：
       - 接收文件 URL 或文件路径（小 JSON 请求，< 1KB）
       - 从对象存储读取文件
       - 执行处理操作（提取音频、分析等）
       - 返回处理结果
    
    3. **创建前端上传工具函数** (`utils/uploadToStorage.ts`)：
       - `uploadFileToStorage`: 基础上传函数
       - `uploadFileToStorageWithProgress`: 带进度跟踪的上传函数
       - 使用 Supabase Storage 客户端直接上传
       - 支持重试机制
    
    4. **创建架构文档** (`@docs/OBJECT_STORAGE_UPLOAD.md`)：
       - 详细说明架构流程
       - API 使用示例
       - 环境变量配置
       - 迁移指南
-   **Impact Scope:**
    -   `api/get-upload-url.ts` (新建文件，获取上传凭证)
    -   `api/process-video.ts` (新建文件，处理视频)
    -   `utils/uploadToStorage.ts` (新建文件，前端上传工具)
    -   `@docs/OBJECT_STORAGE_UPLOAD.md` (新建文件，架构文档)

**技术细节**：
- 对象存储：使用 Supabase Storage（项目已集成）
- 上传流程：前端 → 请求路径 → 直传到 Supabase Storage → 通知后端处理
- 后端只接收：`{ fileUrl, filePath, operation, options }`（< 1KB JSON）
- 优势：突破 4.5MB 限制，更快上传，降低成本，更好扩展性

**使用示例**：
```typescript
// 1. 上传文件到对象存储
const result = await uploadFileToStorageWithProgress(file, {
  onProgress: (progress) => console.log(`${progress}%`),
});

// 2. 通知后端处理
await fetch('/api/process-video', {
  method: 'POST',
  body: JSON.stringify({
    fileUrl: result.fileUrl,
    filePath: result.filePath,
    operation: 'analyze',
  }),
});
```

**后续工作**：
- ✅ 修改视频分析逻辑，使用对象存储 URL（已完成）
- 支持其他对象存储（S3、R2、OSS 等）
- 实现分片上传和断点续传
- 添加文件清理机制

---

### Fix Record - 2025-01-27

-   **Problem Description:** 完成对象存储直传架构的实现：创建 Supabase Storage 存储桶、配置 RLS 策略，并迁移现有代码使用新架构。
-   **Root Cause:** 
    1. 需要创建存储桶和配置 RLS 策略才能使用对象存储
    2. 现有代码需要支持从对象存储 URL 读取文件
    3. 需要自动处理大文件上传到对象存储的逻辑
-   **Solution:** 
    1. **创建 Supabase Storage 迁移文件** (`supabase/migrations/create_video_uploads_storage.sql`)：
       - 创建 RLS 策略：允许认证用户上传、读取、删除文件
       - 允许服务角色（server-side）完全访问
       - 创建索引优化查询性能
       - 包含存储桶创建说明（需手动在 Dashboard 创建）
    
    2. **创建设置文档** (`@docs/SUPABASE_STORAGE_SETUP.md`)：
       - 详细的存储桶创建步骤
       - RLS 策略配置说明
       - 环境变量配置指南
       - 测试和故障排查方法
    
    3. **修改 `prepareAnalysisPayload` 函数** (`services/videoProcessingService.ts`)：
       - 当音频过大（> 4MB）时，自动上传到对象存储
       - 返回对象存储 URL 而不是 base64 数据
       - 添加 `isUrl` 标志区分 URL 和 base64 数据
       - 如果上传失败，降级到视频帧提取
    
    4. **修改 `analyzeVideo` 函数** (`services/geminiService.ts`)：
       - 支持从对象存储 URL 读取音频文件
       - 自动检测 `isUrl` 标志
       - 如果是 URL，先 fetch 然后转换为 base64
       - 保持对直接 base64 数据的兼容性
-   **Impact Scope:**
    -   `supabase/migrations/create_video_uploads_storage.sql` (新建文件，RLS 策略配置)
    -   `@docs/SUPABASE_STORAGE_SETUP.md` (新建文件，设置指南)
    -   `services/videoProcessingService.ts` (添加对象存储上传逻辑)
    -   `services/geminiService.ts` (支持从 URL 读取音频)

**技术细节**：
- 存储桶名称：`video-uploads`
- 文件路径格式：`videos/{timestamp}-{randomId}.{ext}`
- RLS 策略：认证用户可上传/读取/删除，服务角色完全访问
- 自动上传触发：当音频大小 > 4MB（估算请求 > 4MB）时

**使用流程**：
1. 在 Supabase Dashboard 创建 `video-uploads` 存储桶
2. 运行 SQL 迁移文件配置 RLS 策略
3. 配置 `SUPABASE_SERVICE_ROLE_KEY` 环境变量
4. 系统自动处理：小文件直接发送，大文件上传到对象存储

**优化效果**：
- 之前：音频 > 4MB → 超过限制 → 413 错误或降级到视频帧
- 现在：音频 > 4MB → 自动上传到对象存储 → 使用 URL → 成功处理
- 完全突破 4.5MB 限制，支持任意大小的文件

---

### Fix Record - 2025-01-27

-   **Problem Description:** SQL 迁移文件执行失败，错误信息：`syntax error at or near "NOT"`。Supabase 的 `CREATE POLICY` 不支持 `IF NOT EXISTS` 语法。
-   **Root Cause:** 
    1. PostgreSQL/Supabase 的 `CREATE POLICY` 语句不支持 `IF NOT EXISTS` 语法
    2. 迁移文件使用了 `CREATE POLICY IF NOT EXISTS`，导致语法错误
    3. 需要使用 `DROP POLICY IF EXISTS` 然后 `CREATE POLICY` 的方式
-   **Solution:** 
    1. **修复 SQL 迁移文件** (`supabase/migrations/create_video_uploads_storage.sql`)：
       - 移除所有 `CREATE POLICY IF NOT EXISTS` 语句
       - 改为先执行 `DROP POLICY IF EXISTS`，然后执行 `CREATE POLICY`
       - 这样即使策略已存在，也会先删除再创建，避免重复创建错误
    
    2. **更新文档** (`@docs/SUPABASE_STORAGE_SETUP.md`)：
       - 更新 SQL 示例，使用正确的语法
       - 说明 Supabase 不支持 `IF NOT EXISTS` 的原因
-   **Impact Scope:**
    -   `supabase/migrations/create_video_uploads_storage.sql` (修复 SQL 语法)
    -   `@docs/SUPABASE_STORAGE_SETUP.md` (更新 SQL 示例)

**技术细节**：
- PostgreSQL `CREATE POLICY` 不支持 `IF NOT EXISTS`
- 正确做法：`DROP POLICY IF EXISTS ...; CREATE POLICY ...;`
- `DROP POLICY IF EXISTS` 不会报错，即使策略不存在

**修复后的 SQL 模式**：
```sql
DROP POLICY IF EXISTS "policy_name" ON storage.objects;
CREATE POLICY "policy_name" ON storage.objects ...;
```

---

### Fix Record - 2025-01-27

-   **Problem Description:** 上传文件到 Supabase Storage 时出现 "Failed to fetch (api.supabase.com)" 错误，缺少详细的错误诊断信息。
-   **Root Cause:** 
    1. 上传函数缺少前置检查（用户认证、存储桶存在性、配置验证）
    2. 错误信息不够详细，难以定位问题
    3. 没有提供诊断步骤帮助用户排查问题
-   **Solution:** 
    1. **增强上传函数的错误处理** (`utils/uploadToStorage.ts`)：
       - 添加用户认证检查：上传前验证用户是否已登录
       - 添加存储桶存在性检查：验证 `video-uploads` 存储桶是否存在
       - 添加配置验证：检查 Supabase 客户端是否正确初始化
       - 改进错误信息：根据错误类型提供详细的可能原因和解决方案
       - 区分不同类型的错误（网络错误、权限错误等）
    
    2. **更新故障排查文档** (`@docs/SUPABASE_STORAGE_SETUP.md`)：
       - 添加 "Failed to fetch" 错误的详细排查步骤
       - 列出 6 种可能原因和对应的解决方案
       - 提供诊断代码片段，帮助用户快速定位问题
       - 添加检查清单（URL 配置、用户登录、存储桶存在、RLS 策略等）
-   **Impact Scope:**
    -   `utils/uploadToStorage.ts` (增强错误处理和诊断)
    -   `@docs/SUPABASE_STORAGE_SETUP.md` (添加故障排查指南)

**技术细节**：
- 上传前检查：用户认证 → 存储桶存在 → 配置正确
- 错误分类：网络错误、权限错误、配置错误
- 诊断工具：提供浏览器控制台诊断代码

**常见错误原因**：
1. Supabase URL 配置错误（最常见）
2. 用户未登录（存储桶为私有）
3. 存储桶不存在
4. RLS 策略未配置
5. 网络连接问题
6. CORS 配置问题

**诊断代码**：
```typescript
// 在浏览器控制台执行
const { supabase } = await import('./services/authService');
console.log('URL:', import.meta.env.VITE_SUPABASE_URL);
const { data: { session } } = await supabase.auth.getSession();
console.log('Session:', session ? 'Logged in' : 'Not logged in');
const { data: buckets } = await supabase.storage.listBuckets();
console.log('Buckets:', buckets);
```

---

### Fix Record - 2025-01-27

-   **Problem Description:** Linuxdo 登录一直失败，用户无法通过 Linux.do OAuth 完成登录
-   **Root Cause:** 
    1. 错误处理不够详细，用户无法了解具体的失败原因
    2. 网络错误、状态验证失败、配置错误等不同场景的错误信息不够明确
    3. 缺少诊断工具帮助排查配置问题
    4. 错误消息没有提供解决方案提示
-   **Solution:** 
    1. **增强错误处理和诊断** (`services/linuxDoAuthService.ts`)：
       - 在 `exchangeCodeForToken` 函数中添加详细的错误处理：
         - 捕获网络错误并提供友好的错误消息
         - 根据不同的 HTTP 状态码（400, 401, 403, 500+）提供具体的错误信息
         - 解析错误响应（JSON 或文本）并包含在错误消息中
         - 添加 code_verifier 丢失时的详细诊断信息
       - 在 `getLinuxDoUserInfo` 函数中添加类似的错误处理：
         - 捕获网络错误
         - 根据状态码提供具体错误信息
         - 解析错误响应
       - 改进 `verifyState` 函数：
         - 添加详细的日志记录，包括 sessionStorage 状态
         - 记录状态不匹配的详细信息
       - 添加 `diagnoseLinuxDoConfig` 诊断函数：
         - 检查 Client ID 配置状态和来源（环境变量/数据库）
         - 检查 Client Secret 配置
         - 检查 Supabase 配置状态
         - 检查 sessionStorage 中的登录流程状态
         - 提供修复建议列表
    2. **改进错误消息和用户提示**：
       - 在 `App.tsx` 的回调处理中：
         - 为状态验证失败提供详细的原因说明和解决方案
         - 为常见错误（code_verifier、redirect_uri、Client ID）提供解决方案提示
       - 在 `AccountPanel.tsx` 和 `AuthModal.tsx` 中：
         - 为配置错误提供详细的检查清单
         - 引导用户查看浏览器控制台的详细错误信息
    3. **改进登录流程**：
       - 在 `buildLinuxDoAuthUrl` 中清除之前可能存在的状态，防止重复登录导致的问题
       - 添加更详细的日志记录，帮助调试
-   **Impact Scope:**
    -   `services/linuxDoAuthService.ts` (增强错误处理、添加诊断函数、改进日志记录)
    -   `App.tsx` (改进回调错误处理、添加详细错误消息)
    -   `components/AccountPanel.tsx` (改进错误消息、添加配置检查提示)
    -   `components/AuthModal.tsx` (改进错误消息、添加配置检查提示)

**技术细节**：
- 错误分类：网络错误、配置错误、状态验证错误、服务器错误
- 状态码映射：400（授权码无效）→ 401（配置错误）→ 403（回调 URL 问题）→ 500+（服务器错误）
- 诊断工具：`diagnoseLinuxDoConfig()` 函数可用于排查配置问题
- 日志增强：所有关键步骤都添加了详细的日志记录

**常见错误原因和解决方案**：
1. **Client ID 未配置**：检查 Supabase 数据库或环境变量
2. **Code verifier 丢失**：不要在新标签页打开授权页面，重新点击登录按钮
3. **State 验证失败**：确保在同一窗口中完成授权流程
4. **回调 URL 不匹配**：确保 Linux.do 应用中配置的回调 URL 与当前页面 URL 完全匹配
5. **网络错误**：检查网络连接和 Linux.do 服务器状态

**诊断工具使用**：
```typescript
// 在浏览器控制台执行
import { diagnoseLinuxDoConfig } from './services/linuxDoAuthService';
const diagnosis = await diagnoseLinuxDoConfig();
console.log('诊断结果:', diagnosis);
```

---

